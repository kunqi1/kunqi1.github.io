<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="0xkunqil">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="0xkunqil">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Kunqi Liu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>0xkunqil</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">0xkunqil</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">kunqi的技术博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/15/solana-token/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kunqi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0xkunqil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/15/solana-token/" class="post-title-link" itemprop="url">solana-token</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-15 16:49:58" itemprop="dateCreated datePublished" datetime="2024-11-15T16:49:58+08:00">2024-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-16 06:10:23" itemprop="dateModified" datetime="2024-11-16T06:10:23+08:00">2024-11-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="SPL（Solana-Program-Library）"><a href="#SPL（Solana-Program-Library）" class="headerlink" title="SPL（Solana Program Library）"></a>SPL（Solana Program Library）</h3><ol>
<li>Token Program: 代币程序</li>
<li>Mint Account： 铸币账户</li>
<li>Token Account： 代币账户</li>
<li>Associated Token Account（ATA）：关联代币账户</li>
</ol>
<h4 id="账户之间的联系"><a href="#账户之间的联系" class="headerlink" title="账户之间的联系"></a>账户之间的联系</h4><h5 id="代币程序结构："><a href="#代币程序结构：" class="headerlink" title="代币程序结构："></a>代币程序结构：</h5><p><img src="https://raw.githubusercontent.com/kunqi1/kunqi1.github.io/refs/heads/main/images/token-program.svg" alt="代币程序"></p>
<ul>
<li>代币程序包含与网络上的代币（FT与NFT）交互的所有指令逻辑，代币本身是代币程序持有的数据账户</li>
</ul>
<h5 id="铸币账户："><a href="#铸币账户：" class="headerlink" title="铸币账户："></a>铸币账户：</h5><p><img src="https://raw.githubusercontent.com/kunqi1/kunqi1.github.io/refs/heads/main/images/mint-account.svg" alt="铸币账户"></p>
<ul>
<li>代币程序拥有铸造账户的唯一标识，Mint Account相当于存储了特定代币程序的全局权限和计数</li>
<li>属性：</li>
</ul>
<ol>
<li>Decimals（精度）：定义代币的最小单位，通常是0到9；</li>
<li>Supply：代币当前的总供应量；</li>
<li>Mint Authority：可以铸造新代币的账户</li>
<li>Freeze Authority：冻结或解冻账户的权限（可选）</li>
</ol>
<ul>
<li>功能：</li>
</ul>
<ol>
<li>当Mint Authority执行铸币操作时，新的代币会增加到总供应量中，并分配给指定的Token Account</li>
<li>销毁代币，减少总供应量</li>
</ol>
<h5 id="代币账户："><a href="#代币账户：" class="headerlink" title="代币账户："></a>代币账户：</h5><p><img src="https://raw.githubusercontent.com/kunqi1/kunqi1.github.io/refs/heads/main/images/token-account.svg" alt="代币账户"></p>
<ul>
<li><p>代币账户也是由代币程序所持有，跟踪了每个代币的个人所有权，由<code>owner</code>字段标识，所有代币账户的程序权限都是代币程序持有，但是个人代币的所有权由个人钱包地址持有。</p>
</li>
<li><p>属性：</p>
</li>
</ul>
<ol>
<li>Amount: 账户中持有的代币数量</li>
<li>Owner：控制该账户的用户或合约地址</li>
<li>Mint：铸币账户关联，指定该账户与哪个 Mint Account 相互关联</li>
<li>Delegate：代理账户，可以被授权管理该账户的其他账户（可选）</li>
<li>State：账户是否处于冻结状态</li>
</ol>
<ul>
<li>功能</li>
</ul>
<ol>
<li>接收和发送代币：Token Account 可以接受其他账户的代币，也可以通过转账指令发送给其他代币</li>
<li>代理权限管理</li>
</ol>
<h5 id="ATA账户"><a href="#ATA账户" class="headerlink" title="ATA账户"></a>ATA账户</h5><ul>
<li>为了简化查找特定铸造和所有者代币账户地址，通过钱包地址和铸币账户派生的一种程序派生账户PDA，是一种特殊类型的 Token Account</li>
</ul>
<p><img src="https://raw.githubusercontent.com/kunqi1/kunqi1.github.io/refs/heads/main/images/token-account-relationship.svg" alt="ATA账户"></p>
<ul>
<li>特点：</li>
</ul>
<ol>
<li>唯一性：每个钱包地址只能有一个和指定 Mint 关联的 ATA</li>
<li>自动生成： Solana 提供了工具来自动生成ATA，开发者不需要手动管理账户</li>
</ol>
<ul>
<li>功能：</li>
<li>自动处理钱包地址与代币账户之间的关联，方便用户管理不同的 SPL Token</li>
</ul>
<h5 id="账户关系扩展"><a href="#账户关系扩展" class="headerlink" title="账户关系扩展"></a>账户关系扩展</h5><ul>
<li>不同的钱包，为了持有不同的代币，与铸币账户和ATA账户之间的关系结构：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/kunqi1/kunqi1.github.io/refs/heads/main/images/token-account-relationship-ata.svg" alt="账户关系扩展"></p>
<h3 id="Solana-项目结构"><a href="#Solana-项目结构" class="headerlink" title="Solana 项目结构"></a>Solana 项目结构</h3><ul>
<li>核心文件：</li>
</ul>
<ol>
<li>processor.rs: 核心业务逻辑，处理指令</li>
<li>state.rs: 定义账户的状态和扩展字段</li>
<li>instruction.rs: 定义各种代币操作的指令</li>
<li>error.rs: 定义了程序可能抛出的错误</li>
<li>lib.rs: 程序入口点，汇总各个模块</li>
</ol>
<h3 id="实现一个本地Token合约交互"><a href="#实现一个本地Token合约交互" class="headerlink" title="实现一个本地Token合约交互"></a>实现一个本地Token合约交互</h3><ol>
<li>创建mint账号</li>
<li>创建ATA后Mint代币</li>
</ol>
<ul>
<li>processor.rs:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> borsh::BorshDeserialize;</span><br><span class="line"><span class="keyword">use</span> solana_program::&#123;</span><br><span class="line">    account_info::&#123;next_account_info, AccountInfo&#125;, entrypoint::ProgramResult, instruction::Instruction, msg, program::&#123;invoke, invoke_signed&#125;, program_pack::Pack, pubkey::Pubkey, system_instruction, system_program, sysvar::&#123;rent::Rent, Sysvar&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::instruction::TokenInstruction;</span><br><span class="line"><span class="keyword">use</span> spl_token::&#123;instruction::&#123;initialize_mint, mint_to&#125;, state::Mint&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Processor</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">process</span>(</span><br><span class="line">        program_id: &amp;Pubkey,</span><br><span class="line">        accounts: &amp;[AccountInfo],</span><br><span class="line">        instruction_data: &amp;[<span class="type">u8</span>],</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> ProgramResult &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">instruction</span> = TokenInstruction::<span class="title function_ invoke__">try_from_slice</span>(instruction_data)?;</span><br><span class="line">        <span class="keyword">match</span> instruction &#123;</span><br><span class="line">            TokenInstruction::CreateToken&#123;decimals&#125; =&gt; <span class="keyword">Self</span>::<span class="title function_ invoke__">create_token</span>(accounts, decimals),</span><br><span class="line">            TokenInstruction::Mint&#123;amount&#125; =&gt; <span class="keyword">Self</span>::<span class="title function_ invoke__">mint_token</span>(accounts, amount),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_token</span>(accounts: &amp;[AccountInfo], decimals:<span class="type">u8</span>) <span class="punctuation">-&gt;</span> ProgramResult &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">accounts_iter</span> = &amp;<span class="keyword">mut</span> accounts.<span class="title function_ invoke__">iter</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mint_account</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mint_authority</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">payer</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rent_sysvar</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">system_program</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">token_program</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line"></span><br><span class="line">        msg!(<span class="string">&quot;Creating Mint Account...&quot;</span>);</span><br><span class="line">        msg!(<span class="string">&quot;Mint account is &#123;&#125;&quot;</span>, mint_account.key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">create_account_ix</span> = &amp;system_instruction::<span class="title function_ invoke__">create_account</span>(</span><br><span class="line">            payer.key,</span><br><span class="line">            mint_account.key,</span><br><span class="line">            (Rent::<span class="title function_ invoke__">get</span>()?).<span class="title function_ invoke__">minimum_balance</span>(Mint::LEN),</span><br><span class="line">            Mint::LEN <span class="keyword">as</span> <span class="type">u64</span>,</span><br><span class="line">            token_program.key</span><br><span class="line">            );</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="title function_ invoke__">invoke</span>(</span><br><span class="line">            create_account_ix,</span><br><span class="line">            &amp;[</span><br><span class="line">                mint_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                mint_authority.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                payer.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                rent_sysvar.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                system_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                token_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            ]</span><br><span class="line">        )?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mint_init</span> = &amp;<span class="title function_ invoke__">initialize_mint</span>(</span><br><span class="line">            token_program.key, </span><br><span class="line">            mint_account.key, </span><br><span class="line">            mint_authority.key, </span><br><span class="line">            <span class="literal">None</span>, </span><br><span class="line">            decimals</span><br><span class="line">        )?;</span><br><span class="line"></span><br><span class="line">        msg!(<span class="string">&quot;initialized mint!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">invoke_signed</span>(</span><br><span class="line">            mint_init, </span><br><span class="line">            &amp;[</span><br><span class="line">                mint_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                rent_sysvar.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                token_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                mint_authority.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">            ], </span><br><span class="line">            &amp;[]</span><br><span class="line">        )?;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mint_token</span>(accounts: &amp;[AccountInfo], amount: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> ProgramResult &#123;</span><br><span class="line">        msg!(<span class="string">&quot;Creating ATA account ...&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">accounts_iter</span> = &amp;<span class="keyword">mut</span> accounts.<span class="title function_ invoke__">iter</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mint_account</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">associated_token_account</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">payer</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rent_sysvar</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">system_program</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">token_program</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">associated_token_program</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        msg!(<span class="string">&quot;ATA account is &#123;&#125;&quot;</span>, associated_token_account.key);</span><br><span class="line">        <span class="keyword">if</span> associated_token_account.<span class="title function_ invoke__">lamports</span>() == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">mint_ix</span> = spl_associated_token_account::instruction::<span class="title function_ invoke__">create_associated_token_account</span>(</span><br><span class="line">                payer.key, </span><br><span class="line">                payer.key, </span><br><span class="line">                mint_account.key, </span><br><span class="line">                token_program.key, </span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="title function_ invoke__">invoke</span>(</span><br><span class="line">                &amp;mint_ix,</span><br><span class="line">                &amp;[</span><br><span class="line">                    mint_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                    associated_token_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                    rent_sysvar.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                    payer.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                    system_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                    token_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                    associated_token_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                ]</span><br><span class="line">            )?;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mint_to_ix</span> = <span class="title function_ invoke__">mint_to</span>(</span><br><span class="line">            token_program.key, </span><br><span class="line">            mint_account.key, </span><br><span class="line">            associated_token_account.key, </span><br><span class="line">            payer.key, </span><br><span class="line">            &amp;[payer.key], </span><br><span class="line">            amount</span><br><span class="line">        )?;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">invoke</span>(</span><br><span class="line">            &amp;mint_to_ix, </span><br><span class="line">            &amp;[</span><br><span class="line">                mint_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                payer.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                associated_token_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                token_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            ]</span><br><span class="line">        )?;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>instruction.rs:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> borsh::&#123;BorshDeserialize, BorshSerialize&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(BorshDeserialize, BorshSerialize)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">TokenInstruction</span> &#123;</span><br><span class="line">    CreateToken&#123;decimals: <span class="type">u8</span>&#125;,</span><br><span class="line">    Mint&#123;amount: <span class="type">u64</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>lib.rs:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> solana_program::&#123;</span><br><span class="line">    entrypoint,</span><br><span class="line">    account_info::AccountInfo,</span><br><span class="line">    entrypoint::ProgramResult,</span><br><span class="line">    pubkey::Pubkey</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> processor;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> instruction;</span><br><span class="line"></span><br><span class="line">entrypoint!(process_instruction);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">process_instruction</span>(</span><br><span class="line">    program_id: &amp;Pubkey,</span><br><span class="line">    accounts: &amp;[AccountInfo],</span><br><span class="line">    instruction_data: &amp;[<span class="type">u8</span>],</span><br><span class="line">) <span class="punctuation">-&gt;</span> ProgramResult &#123;</span><br><span class="line">    crate::processor::Processor::<span class="title function_ invoke__">process</span>(program_id, accounts, instruction_data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>部署上链</li>
</ul>
<blockquote>
<p>cargo build-bpf<br>solana program deploy [project.so]</p>
</blockquote>
<ul>
<li>客户端测试代码</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>::FromStr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> borsh::&#123;BorshDeserialize, BorshSerialize&#125;;</span><br><span class="line"><span class="keyword">use</span> solana_client::rpc_client::RpcClient;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::instruction::&#123;AccountMeta, Instruction&#125;;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::signature::&#123;read_keypair_file, Keypair&#125;;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::pubkey::Pubkey;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::signer::Signer;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::sysvar;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::transaction::Transaction;</span><br><span class="line"><span class="keyword">use</span> spl_associated_token_account::instruction;</span><br><span class="line"><span class="keyword">use</span> spl_associated_token_account_client::address::get_associated_token_address;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(BorshDeserialize, BorshSerialize)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">TokenInstruction</span> &#123;</span><br><span class="line">    CreateToken&#123;decimals: <span class="type">u8</span>&#125;,</span><br><span class="line">    Mint&#123;amount: <span class="type">u64</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">#[test]</span></span><br><span class="line"> <span class="keyword">fn</span> <span class="title function_">test2</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rpc_client</span> = RpcClient::<span class="title function_ invoke__">new</span>(<span class="string">&quot;http://127.0.0.1:8899&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">payer</span> = <span class="title function_ invoke__">read_keypair_file</span>(<span class="string">&quot;/Users/liukunqi/.config/solana/id.json&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;failed&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">program_id</span> = Pubkey::<span class="title function_ invoke__">from_str</span>(<span class="string">&quot;CjQgCpYRf8ueAJtdatkVDpZaMVzkLzZhDF5NMy78KWkg&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mint_account</span> = Keypair::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">decimals</span>: <span class="type">u8</span> = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    _ = <span class="title function_ invoke__">create_token</span>(</span><br><span class="line">        &amp;rpc_client, </span><br><span class="line">        &amp;payer, </span><br><span class="line">        &amp;program_id, </span><br><span class="line">        &amp;mint_account,</span><br><span class="line">        &amp;payer.<span class="title function_ invoke__">pubkey</span>(),</span><br><span class="line">        decimals</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    _ = <span class="title function_ invoke__">mint</span>(</span><br><span class="line">        &amp;rpc_client,</span><br><span class="line">        &amp;payer,</span><br><span class="line">        &amp;program_id,</span><br><span class="line">        &amp;mint_account,</span><br><span class="line">        <span class="number">100_000_000</span> <span class="keyword">as</span> <span class="type">u64</span></span><br><span class="line">    );</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">fn</span> <span class="title function_">create_token</span>(</span><br><span class="line">     rpc_client: &amp;RpcClient,</span><br><span class="line">     payer: &amp;Keypair,</span><br><span class="line">     program_id: &amp;Pubkey,</span><br><span class="line">     mint_account: &amp;Keypair,</span><br><span class="line">     mint_authority: &amp;Pubkey,</span><br><span class="line">     decimals: <span class="type">u8</span></span><br><span class="line"> ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">instruction_data</span> = borsh::<span class="title function_ invoke__">to_vec</span>(&amp;TokenInstruction::CreateToken &#123; decimals &#125;)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">accounts</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        AccountMeta::<span class="title function_ invoke__">new</span>(mint_account.<span class="title function_ invoke__">pubkey</span>(), <span class="literal">true</span>),</span><br><span class="line">        AccountMeta::<span class="title function_ invoke__">new_readonly</span>(*mint_authority, <span class="literal">false</span>),</span><br><span class="line">        AccountMeta::<span class="title function_ invoke__">new_readonly</span>(payer.<span class="title function_ invoke__">pubkey</span>(), <span class="literal">false</span>),</span><br><span class="line">        AccountMeta::<span class="title function_ invoke__">new_readonly</span>(sysvar::rent::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),</span><br><span class="line">        AccountMeta::<span class="title function_ invoke__">new_readonly</span>(solana_sdk::system_program::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),</span><br><span class="line">        AccountMeta::<span class="title function_ invoke__">new_readonly</span>(spl_token::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">token_instruction</span> = Instruction &#123;</span><br><span class="line">        program_id: *program_id,</span><br><span class="line">        accounts,</span><br><span class="line">        data: instruction_data,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">latest_blockhash</span> = rpc_client.<span class="title function_ invoke__">get_latest_blockhash</span>()?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tx</span> = Transaction::<span class="title function_ invoke__">new_signed_with_payer</span>(</span><br><span class="line">        &amp;[token_instruction], </span><br><span class="line">        <span class="title function_ invoke__">Some</span>(&amp;payer.<span class="title function_ invoke__">pubkey</span>()), </span><br><span class="line">        &amp;[payer, mint_account], </span><br><span class="line">        latest_blockhash</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;tx is &#123;:?&#125;&quot;</span>, tx);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = rpc_client.<span class="title function_ invoke__">send_and_confirm_transaction</span>(&amp;tx)?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Received transaction:&#123;&#125;&quot;</span>, r);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">fn</span> <span class="title function_">mint</span>(     </span><br><span class="line">    rpc_client: &amp;RpcClient,</span><br><span class="line">    payer: &amp;Keypair,</span><br><span class="line">    program_id: &amp;Pubkey,</span><br><span class="line">    mint_account: &amp;Keypair,</span><br><span class="line">    amount: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">instruction_data</span> = borsh::<span class="title function_ invoke__">to_vec</span>(&amp;TokenInstruction::Mint &#123; amount &#125;)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ata_addr</span> = <span class="title function_ invoke__">get_associated_token_address</span>(</span><br><span class="line">            &amp;payer.<span class="title function_ invoke__">pubkey</span>(), </span><br><span class="line">            &amp;mint_account.<span class="title function_ invoke__">pubkey</span>()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;ata_addr is :&#123;:?&#125;&quot;</span>, ata_addr.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">accounts</span> = <span class="built_in">vec!</span>[</span><br><span class="line">            AccountMeta::<span class="title function_ invoke__">new</span>(mint_account.<span class="title function_ invoke__">pubkey</span>(), <span class="literal">true</span>),</span><br><span class="line">            AccountMeta::<span class="title function_ invoke__">new</span>(ata_addr, <span class="literal">false</span>),</span><br><span class="line">            AccountMeta::<span class="title function_ invoke__">new</span>(payer.<span class="title function_ invoke__">pubkey</span>(), <span class="literal">true</span>),</span><br><span class="line">            AccountMeta::<span class="title function_ invoke__">new_readonly</span>(sysvar::rent::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),</span><br><span class="line">            AccountMeta::<span class="title function_ invoke__">new_readonly</span>(solana_sdk::system_program::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),</span><br><span class="line">            AccountMeta::<span class="title function_ invoke__">new_readonly</span>(spl_token::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),</span><br><span class="line">            AccountMeta::<span class="title function_ invoke__">new_readonly</span>(spl_associated_token_account::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),</span><br><span class="line">        ];</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">token_instruction</span> = Instruction &#123;</span><br><span class="line">            program_id: *program_id,</span><br><span class="line">            accounts,</span><br><span class="line">            data: instruction_data,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">latest_blockhash</span> = rpc_client.<span class="title function_ invoke__">get_latest_blockhash</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">tx</span> = Transaction::<span class="title function_ invoke__">new_signed_with_payer</span>(</span><br><span class="line">            &amp;[token_instruction], </span><br><span class="line">            <span class="title function_ invoke__">Some</span>(&amp;payer.<span class="title function_ invoke__">pubkey</span>()), </span><br><span class="line">            &amp;[payer, mint_account], </span><br><span class="line">            latest_blockhash</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//println!(&quot;tx is &#123;:?&#125;&quot;, tx);</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rx</span> = rpc_client.<span class="title function_ invoke__">send_and_confirm_transaction_with_spinner</span>(&amp;tx);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Signature is: &#123;:?&#125;&quot;</span>, rx);</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试结果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> ---- test_encrypt_decrypt stdout ----</span><br><span class="line">Received transaction:2PCtoaXWkU9HXMJbcMvgDKqrsveHE2t3NRHXfopRZXJXw3ZrD3pdU9vbzowtaBC2C9dzxdWgLmJbnaKhjtnQPzrq</span><br><span class="line"></span><br><span class="line">ata_addr is :&quot;5A9qPnY65sVZ8UbkWS7uyqd6JDNes6GcMrD1i8HSzGWk&quot;</span><br><span class="line">Signature is: Ok(5Xjc8bMT4i1b5EWwujoEj1pherj4jjyxqD2FmtzmwSD6SuFnwfD75ssbi6uT76WxuaPDCfGKgPADdrQAE7ihevH7)</span><br></pre></td></tr></table></figure>

<ul>
<li>可到区块链浏览器查看部署上链的结果</li>
<li>记得查询前网络改成部署节点网络，可以是本地也可以是开发测试网</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/14/account-and-interaction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kunqi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0xkunqil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/14/account-and-interaction/" class="post-title-link" itemprop="url">Solana 账户与基本交互</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-14 14:41:06" itemprop="dateCreated datePublished" datetime="2024-11-14T14:41:06+08:00">2024-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-15 14:07:29" itemprop="dateModified" datetime="2024-11-15T14:07:29+08:00">2024-11-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Solana-账户模型"><a href="#Solana-账户模型" class="headerlink" title="Solana 账户模型"></a>Solana 账户模型</h3><ul>
<li>在 Solana 上，所有数据都存储在所谓的“帐户”中。 Solana 上的数据组织方式类似 于键值存储，其中数据 库中的每个条目称为“帐户(Account)”。<br><img src="https://raw.githubusercontent.com/kunqi1/kunqi1.github.io/refs/heads/main/images/accounts.svg" alt="账户模型"></li>
</ul>
<h4 id="核心要点"><a href="#核心要点" class="headerlink" title="核心要点"></a>核心要点</h4><ol>
<li><p>账户最多可存储10MB 数据，这些数据可以由可执行的程序代码或程序状态组成。</p>
</li>
<li><p>账户需要以 SOL 形式存入租金，与存储数据的数量成比例，当账户关闭时，该金额可以 全额退款。</p>
</li>
<li><p>每个帐户都有一个程序“所有者”。 只有拥有帐户的程序可以修改其数据或扣除其lamport 余额。 然而，任何人都可以增加的余额。</p>
</li>
<li><p>程序 (智能合约) 是无状态账户，用于存储可执行代码。</p>
</li>
<li><p>数据账户是由程序创建的，用于存储和管理程序状态。</p>
</li>
<li><p>原生程序是内置程序，包括在 Solana 运行时内。</p>
</li>
<li><p>Sysvar 帐户是存储网络集群状态的特殊帐户</p>
</li>
</ol>
<h4 id="账户"><a href="#账户" class="headerlink" title="账户"></a>账户</h4><ul>
<li><p>每个帐户都可以通过其唯一的地址来识别，用 <code>Ed25519 PublicKey</code> 格式。 你可以将地址的视为账户的唯一标识符。<br><img src="https://raw.githubusercontent.com/kunqi1/kunqi1.github.io/refs/heads/main/images/account-address.svg" alt="账户地址"></p>
</li>
<li><p>地址是定位相应的链上账户数据的键</p>
</li>
</ul>
<h4 id="账户信息"><a href="#账户信息" class="headerlink" title="账户信息"></a>账户信息</h4><ul>
<li>帐户有一个 最大大小为 <code>10MB(10 Mega Bytes)</code> ，并且 <code>Solana</code> 上每个帐户上存储的数据有以下结构称为 <code>AccountInfo</code>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/kunqi1/kunqi1.github.io/refs/heads/main/images/accountinfo.svg" alt="账户信息"></p>
<ul>
<li>每个账户的 AccountInfo 包含以下字段：</li>
</ul>
<ol>
<li><code>data</code>: 存储帐户状态的字节数组。 如果帐户是程序(智能合约)，则存储可执行程序代码。 此字段通常称为<code>“帐户数据”</code>。</li>
<li><code>executable</code>: 表示帐户是否为程序的布尔标识符。</li>
<li><code>lamports</code>：账户余额的数字表示方式为 <code>lamports</code>，这是SOL中最小的单位<code>(1 SOL = 10亿 lamports)</code>。</li>
<li><code>owner</code>：指定哪一个程序的公钥 (程序ID) 拥有该帐户。</li>
<li>作为<code>Solana</code> 账户模式的一个关键部分，<code>Solana</code> 上的每个账户都有一个指定为“所有者”，特别是一个程序。 只有指定为帐户所有者的程序可以修改帐户中存储的数据或扣除<code>lamport</code>余额。 重要的是虽然只有<code>所有者</code>可以扣除余额，但任何人都可以增加余额。</li>
</ol>
<h4 id="原生程序"><a href="#原生程序" class="headerlink" title="原生程序"></a>原生程序</h4><ul>
<li><p>Solana 包含少数原生程序，这些程序是验证器实现的一部分，并为网络提供了各种核心功能。 你可以这里找到原生程序的完整列表。</p>
</li>
<li><p>当在 Solana 上开发自定义程序时，你通常会与两个原生程序交互，即系统程序和 BPF Loader。</p>
</li>
</ul>
<h4 id="系统程序"><a href="#系统程序" class="headerlink" title="系统程序"></a>系统程序</h4><ul>
<li>默认情况下，所有新账户都属于系统程序。 系统程序执行几项关键任务，例如：</li>
</ul>
<ol>
<li>新账户创建: 只有系统程序可以创建新帐户。</li>
<li>空间分配: 设置每个帐户数据字节的容量。</li>
<li>分配程序所有者: 一旦系统程序创建了一个帐户，它可以将指定的程序所有者重新分配到不同的程序帐户。 这是自定义程序如何获取系统程序创建的新账户的所有权。</li>
<li>在Solana上，“钱包”只是系统程序拥有的帐户。 钱包的 lamport 余额是账户拥有的 SOL金额。</li>
</ol>
<h4 id="BPFLoader-程序"><a href="#BPFLoader-程序" class="headerlink" title="BPFLoader 程序"></a>BPFLoader 程序</h4><ul>
<li>BPF Loader 是指定为网络上所有其他程序的“所有者”的程序，不包括原生程序。 它负责部署、升级和执行自定义程序。</li>
</ul>
<h4 id="Sysvar-帐户"><a href="#Sysvar-帐户" class="headerlink" title="Sysvar 帐户"></a>Sysvar 帐户</h4><ul>
<li>Sysvar账户是位于预定义地址的特殊账户，可以访问集群状态数据。 这些帐户使用网络集群的数据动态更新。 你可以在这里找到 Sysvar 账户的完整列表。</li>
</ul>
<h4 id="自定义程序"><a href="#自定义程序" class="headerlink" title="自定义程序"></a>自定义程序</h4><ul>
<li>在 Solana，“智能合约”称为 programs。 程序是一个包含可执行代码的帐户，由一个设置为真的 “executable” 标志表示。</li>
</ul>
<h4 id="程序账户"><a href="#程序账户" class="headerlink" title="程序账户"></a>程序账户</h4><ul>
<li>当新程序为已部署时， 从技术上讲，Solana 上创建了三个独立的账户：</li>
</ul>
<ol>
<li>程序账户: 代表链上程序的主账户。 此帐户存储可执行数据帐户的地址(存储编译的程序代码)和程序的更新权限(授权地址更改程序)。程序可执行数据帐户:包含可执行文件的帐户程序的字节码。</li>
<li>缓冲帐户：一个临时帐户，在程序正在部署或升级时存储字节代码。 处理完成后，数据将转入程序可执行数据账户，并关闭缓冲账户。</li>
</ol>
<ul>
<li><p>例如，这里是 Solana 浏览器上的 Token 扩展的程序账户链接及其相应的程序可执行数据帐户。</p>
</li>
<li><p>“程序帐户”的地址通常称为“程序ID”，用于调用该程序。</p>
</li>
</ul>
<h4 id="数据帐户"><a href="#数据帐户" class="headerlink" title="数据帐户"></a>数据帐户</h4><ul>
<li><p>Solana 程序是“无状态”的，这意味着程序帐户只包含程序可执行字节代码。 要存储和修改额外数据，必须创建新的帐户。 这些账户通常称为“数据账户”。</p>
</li>
<li><p>数据账户可以存储在所有者程序的代码中定义的任意数据。</p>
</li>
<li><p>注意，只有 System Program 可以创建新帐户。 一旦系统程序创建了一个帐户，它就可以将新帐户的所有权转移到另一个程序。</p>
</li>
<li><p>换言之，为自定义程序创建数据账户需要两个步骤：</p>
</li>
<li><p>调用系统程序来创建一个帐户，然后将所有权转到一个自定义程序</p>
</li>
<li><p>调用现在拥有账户的自定义程序，然后初始化程序代码中定义的账户数据</p>
</li>
<li><p>这个数据账户创建过程常常是抽象为一步，但是了解基础过程是有用的。</p>
</li>
</ul>
<h4 id="Solana-SDK测试"><a href="#Solana-SDK测试" class="headerlink" title="Solana SDK测试"></a>Solana SDK测试</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// id:C3M8sM1JmSXEn9ubGccBf5VCYMChCUNZFrBcjsQ87hLg</span></span><br><span class="line"><span class="comment">// id2: 3baBhLdkPk9AwG16XWaBd1DrwxLXAnLY7rjxHeL48Kaw</span></span><br><span class="line"><span class="keyword">use</span> solana_client::rpc_client::RpcClient;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::pubkey::Pubkey;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::signature::read_keypair_file;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::signer::Signer;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::system_instruction;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::transaction::Transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>::FromStr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rpc_url</span> = <span class="string">&quot;http://127.0.0.1:8899&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">client</span> = RpcClient::<span class="title function_ invoke__">new</span>(rpc_url);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sender</span> = <span class="title function_ invoke__">read_keypair_file</span>(<span class="string">&quot;/Users/liukunqi/.config/solana/id.json&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;read failed&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">receiver</span> = Pubkey::<span class="title function_ invoke__">from_str</span>(<span class="string">&quot;3baBhLdkPk9AwG16XWaBd1DrwxLXAnLY7rjxHeL48Kaw&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">amount</span> = <span class="number">1_000_000_000</span>; <span class="comment">// 1 sol</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">transfer_instruction</span> = system_instruction::<span class="title function_ invoke__">transfer</span>(&amp;sender.<span class="title function_ invoke__">pubkey</span>(), &amp;receiver, amount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">recent_blockhash</span> = client.<span class="title function_ invoke__">get_latest_blockhash</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">transaction</span> = Transaction::<span class="title function_ invoke__">new_signed_with_payer</span>(</span><br><span class="line">        &amp;[transfer_instruction], </span><br><span class="line">        <span class="title function_ invoke__">Some</span>(&amp;sender.<span class="title function_ invoke__">pubkey</span>()), </span><br><span class="line">        &amp;[&amp;sender], </span><br><span class="line">        recent_blockhash</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = client.<span class="title function_ invoke__">send_and_confirm_transaction</span>(&amp;transaction);</span><br><span class="line">    <span class="keyword">match</span> result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(signature) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;交易签名：&#123;&#125;&quot;</span>, signature),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取账户余额</span></span><br><span class="line">    <span class="keyword">match</span> client.<span class="title function_ invoke__">get_balance</span>(&amp;receiver) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(balance) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;被转账账户余额：&#123;&#125;&quot;</span>, balance),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> client.<span class="title function_ invoke__">get_balance</span>(&amp;sender.<span class="title function_ invoke__">pubkey</span>()) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(balance) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;转出账户余额：&#123;&#125;&quot;</span>, balance),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对于以上代码，我们需要先设置好 solana 的网络地址，我们这次在本地部署,先起一个终端，执行</p>
<blockquote>
<p>solana-test-validator –reset</p>
</blockquote>
</li>
<li><p>另起一个终端，通过 solana-keygen 创建两个新钱包</p>
</li>
</ul>
<blockquote>
<p>solana-keygen new -o ~&#x2F;.config&#x2F;solana&#x2F;id.json<br>solana-keygen new -o ~&#x2F;.config&#x2F;solana&#x2F;id2.json</p>
</blockquote>
<ul>
<li><p>id2 输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Wrote new keypair to /Users/liukunqi/.config/solana/id2.json</span><br><span class="line">===============================================================================</span><br><span class="line">pubkey: 3baBhLdkPk9AwG16XWaBd1DrwxLXAnLY7rjxHeL48Kaw</span><br><span class="line">===============================================================================</span><br><span class="line">Save this seed phrase and your BIP39 passphrase to recover your new keypair:</span><br><span class="line">worry r***emain*** excit***e jazz a****** reflect excuse cotton venue dose raccoon sense // 模糊处理</span><br><span class="line">===============================================================================</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们得到两个钱包的密钥对</p>
</li>
<li><p>通过指令可以在钱包之间切换</p>
</li>
</ul>
<blockquote>
<p>solana config set –keypair ~&#x2F;.config&#x2F;solana&#x2F;id2.json </p>
</blockquote>
<ul>
<li>通过balance指令可以查询余额</li>
</ul>
<blockquote>
<p>solana balance</p>
</blockquote>
<ul>
<li>编译两次后上述事例代码输出</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">交易签名：1zgyPYmzDcyQakR5vazPg9xLZyDaojD2KGRvFCshA1RXVFQbVqfix1fvXbzcAKhdnfAmfnzki6gjBaa1ddcMvfi</span><br><span class="line">被转账账户余额：2000000000</span><br><span class="line">转出账户余额：499999997999990000</span><br></pre></td></tr></table></figure>

<ul>
<li>可以查询到，发生了两次转账行为</li>
</ul>
<h4 id="通俗总结"><a href="#通俗总结" class="headerlink" title="通俗总结"></a>通俗总结</h4><ul>
<li><p>Solana 中的账户主要分为三种类型：</p>
</li>
<li><p>数据账户：用于存储数据。</p>
</li>
<li><p>程序账户：用于存储可执行程序。</p>
</li>
<li><p>原生账户：指 Solana 上的原生程序，例如 System、Stake 以及 Vote。</p>
</li>
<li><p>其中，数据账户可进一步分为两类：</p>
</li>
<li><p>系统所有账户：由 Solana 上的原生程序生成的账户。</p>
</li>
<li><p>程序派生账户 (PDA)：签名权限是程序的帐户，因此不像其他帐户那样受私钥控制。</p>
</li>
<li><p>每个账户都有一个地址（一般情况下是一个公钥）以及一个所有者（程序账户的地址）。前者与以太坊上的类似，后者可以简单理解为创建该账户的程序。</p>
</li>
<li><p>普通用户通过钱包生成的账户属于数据账户中的系统所有账户，默认的账户所有者是系统程序。我们可以简单理解为：用户通过系统程序生成了一个系统所有账户，这个账户存储了用户的基本信息和资产等数据，而这个账户拥有一个地址（也就是公钥）。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/14/solana-keygen/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kunqi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0xkunqil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/14/solana-keygen/" class="post-title-link" itemprop="url">solana-keygen recover时，返回不同pubkey的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-11-14 13:02:37 / Modified: 13:11:47" itemprop="dateCreated datePublished" datetime="2024-11-14T13:02:37+08:00">2024-11-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>在 Solana 中，使用 solana-keygen 创建的密钥对是基于 BIP-39 标准的种子短语（seed phrase）生成的，但如果你遇到了通过 种子短语 恢复时得到的公钥与原始公钥不一致，可能是因为以下几个原因：</li>
</ul>
<ol>
<li>密钥对的种子派生路径（Derivation Path）</li>
</ol>
<ul>
<li><p>Solana 支持基于种子短语的密钥派生，使用 HD（Hierarchical Deterministic）钱包模型。不同的“派生路径”（derivation path）会影响生成的公钥。一个派生路径决定了如何从种子短语派生出不同的密钥对。</p>
</li>
<li><p>默认情况下，solana-keygen 使用 m&#x2F;44’&#x2F;501’ 作为派生路径，符合 BIP-44 标准，并且 501 是 Solana 的 专用币种代码。</p>
</li>
<li><p>如果你恢复钱包时使用的派生路径与最初生成钱包时不同，就会得到不同的公钥。</p>
</li>
</ul>
<ol start="2">
<li>不同的密钥生成工具或库</li>
</ol>
<ul>
<li>如果你用不同的工具（比如 solana-keygen 和其他 HD 钱包库）恢复钱包，可能会因为它们使用了不同的 默认派生路径 或 密钥算法（如 BIP-39 或 BIP-32）而导致不一致的结果。</li>
</ul>
<ol start="3">
<li>错误的恢复过程</li>
</ol>
<ul>
<li><p>确保在恢复时你使用的是正确的种子短语，并且在恢复时没有出现任何错误。即使一个字符错误或顺序错误也会导致完全不同的密钥对和公钥。</p>
</li>
<li><p>如何验证和确保公钥一致</p>
</li>
<li><p>为了确保通过 种子短语 恢复得到正确的密钥对和公钥，可以检查和统一以下几点：</p>
</li>
</ul>
<ol>
<li>检查派生路径</li>
</ol>
<ul>
<li><p>确保在恢复时，使用与生成时相同的 派生路径。Solana 默认使用的路径是 m&#x2F;44’&#x2F;501’&#x2F;0’&#x2F;0’，其中：</p>
</li>
<li><p>44’：BIP-44 规范</p>
</li>
<li><p>501’：Solana 货币类型的硬编码值</p>
</li>
<li><p>如果你自己修改了派生路径（或者其他工具使用了不同的派生路径），就会得到不同的密钥。</p>
</li>
</ul>
<ol start="2">
<li>恢复过程</li>
</ol>
<ul>
<li>使用 solana-keygen 恢复密钥时，可以明确指定派生路径来确保一致性。例如：</li>
</ul>
<blockquote>
<p>solana-keygen recover “prompt:&#x2F;&#x2F;?key&#x3D;0&#x2F;0” –outfile ~&#x2F;my-wallet.json</p>
</blockquote>
<ul>
<li>在上面的命令中，prompt:&#x2F;&#x2F;?key&#x3D;0&#x2F;0 指定了你要恢复的派生路径。</li>
</ul>
<ol start="3">
<li>比较恢复的公钥</li>
</ol>
<ul>
<li>恢复之后，你可以用恢复后的密钥生成公钥，并与原始公钥进行比较：</li>
</ul>
<blockquote>
<p>solana-keygen pubkey ~&#x2F;my-wallet.json</p>
</blockquote>
<ul>
<li>这将显示通过恢复的密钥生成的公钥，与你之前生成的公钥进行比较。</li>
</ul>
<ol start="4">
<li>使用相同的工具和版本</li>
</ol>
<ul>
<li>确保你使用相同的版本和工具来生成和恢复密钥对。如果你在不同的工具或不同版本之间切换，也可能会出现不一致的情况。</li>
</ul>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul>
<li>如果通过 种子短语 恢复密钥时得到的公钥地址不同，最常见的原因是使用了不同的 派生路径 或 工具&#x2F;版本。</li>
<li>确保在恢复时指定正确的 派生路径，通常默认是 m&#x2F;44’&#x2F;501’&#x2F;0’&#x2F;0’，并检查使用的工具版本一致性。</li>
<li>如果有不同的生成方法，必须保证你使用的每个步骤和参数是完全相同的。</li>
<li>如果仍然有问题，请检查你的恢复过程和工具参数，或者提供更多的上下文以便进一步排查。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/13/fourteenth/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kunqi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0xkunqil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/13/fourteenth/" class="post-title-link" itemprop="url">Rust基础：使用消息传递在线程中通信</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-11-13 15:32:44 / Modified: 18:09:41" itemprop="dateCreated datePublished" datetime="2024-11-13T15:32:44+08:00">2024-11-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="使用消息传递实现并发"><a href="#使用消息传递实现并发" class="headerlink" title="使用消息传递实现并发"></a>使用消息传递实现并发</h3><ul>
<li><p>一个日益流行的确保安全并发的方式是 消息传递（message passing），这里线程或 actor 通过发送包含数据的消息来相互沟通。这个思想来源于 Go 编程语言文档中 的口号：“不要通过共享内存来通讯；而是通过通讯来共享内存。”（“Do not communicate by sharing memory; instead, share memory by communicating.”）</p>
</li>
<li><p>为了实现消息传递并发，Rust 标准库提供了一个 信道（channel）实现。信道是一个通用编程概念，表示数据从一个线程发送到另一个线程。</p>
</li>
<li><p>编程中的信息渠道（信道）有两部分组成，一个发送者（sender）和一个接收者（receiver）。发送者位于上游位置，在这里可以将橡皮鸭放入河中，接收者则位于下游，橡皮鸭最终会漂流至此。代码中的一部分调用发送者的方法以及希望发送的数据，另一部分则检查接收端收到的消息。当发送者或接收者任一被丢弃时可以认为信道被 关闭（closed）了。</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>创建一个信道，并将其两端赋值给 tx 和 rx, 返回的是一个元组类型</p>
</li>
<li><p>这里使用 <code>mpsc::channel</code> 函数创建一个新的信道；mpsc 是 <code>多个生产者，单个消费者（multiple producer, single consumer</code>的缩写。简而言之，Rust 标准库实现信道的方式意味着一个信道可以有多个产生值的 发送（sending）端，但只能有一个消费这些值的 接收（receiving）端。想象一下多条小河小溪最终汇聚成大河：所有通过这些小河发出的东西最后都会来到下游的大河。目前我们以单个生产者开始，但是当示例可以工作后会增加多个生产者。</p>
</li>
<li><p><code>mpsc::channel</code> 函数返回一个元组：第一个元素是发送端 – 发送者，而第二个元素是接收端 – 接收者。由于历史原因，tx 和 rx 通常作为 发送者（transmitter）和 接收者（receiver）的缩写，所以这就是我们将用来绑定这两端变量的名字。这里使用了一个 let 语句和模式来解构了此元组。</p>
</li>
</ul>
<p>让我们将发送端移动到一个新建线程中并发送一个字符串，这样新建线程就可以和主线程通讯了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">val</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里再次使用 <code>thread::spawn</code> 来创建一个新线程并使用 <code>move</code> 将 <code>tx</code> 移动到闭包中这样新建线程就拥有 <code>tx</code> 了。新建线程需要拥有信道的发送端以便能向信道发送消息。信道的发送端有一个 <code>send</code> 方法用来获取需要放入信道的值。<code>send</code> 方法返回一个 <code>Result&lt;T, E&gt;</code> 类型，所以如果接收端已经被丢弃了，将没有发送值的目标，所以发送操作会返回错误。在这个例子中，出错的时候调用 <code>unwrap</code> 产生 <code>panic</code>。不过对于一个真实程序，需要合理地处理它。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">val</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">received</span> = rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;received&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>信道的接收者有两个有用的方法：<code>recv</code> 和 <code>try_recv</code>。这里，我们使用了 <code>recv</code>，它是 <code>receive</code> 的缩写。这个方法会阻塞主线程执行直到从信道中接收一个值。一旦发送了一个值，<code>recv</code> 会在一个 <code>Result&lt;T, E&gt;</code> 中返回它。当信道发送端关闭，<code>recv</code> 会返回一个错误表明不会再有新的值到来了。</p>
</li>
<li><p><code>try_recv</code> 不会阻塞，相反它立刻返回一个 <code>Result&lt;T, E&gt;</code>：Ok 值包含可用的信息，而 Err 值代表此时没有任何消息。如果线程在等待消息过程中还有其他工作时使用 <code>try_recv</code> 很有用：可以编写一个循环来频繁调用 <code>try_recv</code>，在有可用消息时进行处理，其余时候则处理一会其他工作直到再次检查。</p>
</li>
<li><p>出于简单的考虑，这个例子使用了 recv；主线程中除了等待消息之外没有任何其他工作，所以阻塞主线程是合适的。</p>
</li>
</ul>
<p>如果运行代码，我们将会看到主线程打印出这个值：</p>
<blockquote>
<p>Got: hi</p>
</blockquote>
<h4 id="信道与所有权转移"><a href="#信道与所有权转移" class="headerlink" title="信道与所有权转移"></a>信道与所有权转移</h4><ul>
<li>所有权规则在消息传递中扮演了重要角色，其有助于我们编写安全的并发代码。防止并发编程中的错误是在 Rust 程序中考虑所有权的一大优势。现在让我们做一个试验来看看信道与所有权如何一同协作以避免产生问题：我们将尝试在新建线程中的信道中发送完 val 值 之后 再使用它。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">val</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;val is &#123;val&#125;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">received</span> = rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;received&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里尝试在通过 <code>tx.send</code> 发送 <code>val</code> 到信道中之后将其打印出来。允许这么做是一个坏主意：一旦将值发送到另一个线程后，那个线程可能会在我们再次使用它之前就将其修改或者丢弃。其他线程对值可能的修改会由于不一致或不存在的数据而导致错误或意外的结果。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling message-passing v0.1.0 (file:///projects/message-passing)</span><br><span class="line">error[E0382]: borrow of moved value: `val`</span><br><span class="line">  --&gt; src/main.rs:10:26</span><br><span class="line">   |</span><br><span class="line">8  |         let val = String::from(&quot;hi&quot;);</span><br><span class="line">   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait</span><br><span class="line">9  |         tx.send(val).unwrap();</span><br><span class="line">   |                 --- value moved here</span><br><span class="line">10 |         println!(&quot;val is &#123;val&#125;&quot;);</span><br><span class="line">   |                          ^^^^^ value borrowed here after move</span><br><span class="line">   |</span><br><span class="line">   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0382`.</span><br><span class="line">error: could not compile `message-passing` (bin &quot;message-passing&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure></li>
<li>我们的并发错误会造成一个编译时错误。<code>send</code> 函数获取其参数的所有权并移动这个值归接收者所有。这可以防止在发送后再次意外地使用这个值；所有权系统检查一切是否合乎规则。</li>
</ul>
<h4 id="发送多个值并观察接收者的等待"><a href="#发送多个值并观察接收者的等待" class="headerlink" title="发送多个值并观察接收者的等待"></a>发送多个值并观察接收者的等待</h4><ul>
<li>新建线程现在会发送多个消息并在每个消息之间暂停一秒钟。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">vals</span> = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;from&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;the&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;thread&quot;</span>),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">received</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;received&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这一次，在新建线程中有一个字符串 <code>vector</code> 希望发送到主线程。我们遍历它们，单独的发送每一个字符串并通过一个 <code>Duration</code> 值调用 <code>thread::sleep</code> 函数来暂停一秒。</p>
</li>
<li><p>在主线程中，不再显式调用 <code>recv</code> 函数：而是将 <code>rx</code> 当作一个迭代器。对于每一个接收到的值，我们将其打印出来。当信道被关闭时，迭代器也将结束。</p>
</li>
</ul>
<p>当运行代码时，将看到如下输出，每一行都会暂停一秒：</p>
<blockquote>
<p>Got: hi<br>Got: from<br>Got: the<br>Got: thread  </p>
</blockquote>
<ul>
<li>因为主线程中的 for 循环里并没有任何暂停或等待的代码，所以可以说主线程是在等待从新建线程中接收值。</li>
</ul>
<h4 id="通过克隆发送者来创建多个生产者"><a href="#通过克隆发送者来创建多个生产者" class="headerlink" title="通过克隆发送者来创建多个生产者"></a>通过克隆发送者来创建多个生产者</h4><p>之前我们提到了mpsc是 multiple producer, single consumer 的缩写。可以运用 mpsc 来扩展示例:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">tx1</span> = tx.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vals</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>),</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;from&quot;</span>),</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;the&quot;</span>),</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;thread&quot;</span>),</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> vals &#123;</span><br><span class="line">        tx1.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vals</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;more&quot;</span>),</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;messages&quot;</span>),</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;for&quot;</span>),</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;you&quot;</span>),</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> vals &#123;</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">received</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;received&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --snip--</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这一次，在创建新线程之前，我们对发送者调用了 clone 方法。这会给我们一个可以传递给第一个新建线程的发送端句柄。我们会将原始的信道发送端传递给第二个新建线程。这样就会有两个线程，每个线程将向信道的接收端发送不同的消息。</li>
</ul>
<p>会看到这样的输出：</p>
<blockquote>
<p>Got: hi<br>Got: more<br>Got: from<br>Got: messages<br>Got: for<br>Got: the<br>Got: thread<br>Got: you  </p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/11/thirteenth/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kunqi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0xkunqil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/11/thirteenth/" class="post-title-link" itemprop="url">Rust基础：并发与共享内存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-11 20:30:16" itemprop="dateCreated datePublished" datetime="2024-11-11T20:30:16+08:00">2024-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-13 18:25:48" itemprop="dateModified" datetime="2024-11-13T18:25:48+08:00">2024-11-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="共享内存通讯"><a href="#共享内存通讯" class="headerlink" title="共享内存通讯"></a>共享内存通讯</h3><ul>
<li><p>让多个线程访问同一块内存中的数据（共享状态）。再考虑一下 Go 语言文档中的这句口号：“不要通过共享内存来通讯”（“do not communicate by sharing memory.）”</p>
</li>
<li><p>在某种程度上，任何编程语言中的信道都类似于单所有权，因为一旦将一个值传送到信道中，将无法再使用这个值。共享内存类似于多所有权：多个线程可以同时访问相同的内存位置。在 15 章中，我们介绍了智能指针可以实现多所有权，然而这会增加额外的复杂性，因为需要管理多个所有者。Rust 的类型系统和所有权规则在正确管理这些问题上提供了极大的帮助：举个例子，让我们来看看 互斥器，一个较常见的共享内存并发原语。</p>
</li>
</ul>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><ul>
<li><p>使用互斥器，实现同一时刻只允许一个线程访问数据</p>
</li>
<li><p>互斥器（mutex）是 互相排斥（mutual exclusion）的缩写。在同一时刻，其只允许一个线程对数据拥有访问权。为了访问互斥器中的数据，线程首先需要通过获取互斥器的 锁（lock）来表明其希望访问数据。锁是一个数据结构，作为互斥器的一部分，它记录谁有数据的专属访问权。因此我们讲，互斥器通过锁系统 保护（guarding）其数据。</p>
</li>
<li><p>互斥器以难以使用著称（译注：原文指互斥器在其他编程语言中难以使用），因为你必须记住：</p>
</li>
</ul>
<ol>
<li>在使用数据之前，必须获取锁。<br>2。 使用完被互斥器所保护的数据之后，必须解锁数据，这样其他线程才能够获取锁。</li>
</ol>
<ul>
<li><p>作为一个现实中互斥器的例子，想象一下在某个会议的一次小组座谈会中，只有一个麦克风。如果一位成员要发言，他必须请求或表示希望使用麦克风。得到了麦克风后，他可以畅所欲言，讲完后再将麦克风交给下一位希望讲话的成员。如果一位成员结束发言后忘记将麦克风交还，其他人将无法发言。如果对共享麦克风的管理出现了问题，座谈会将无法正常进行！</p>
</li>
<li><p>正确的管理互斥器异常复杂，这也是许多人之所以热衷于信道的原因。然而，在 Rust 中，得益于类型系统和所有权，我们不会在锁和解锁上出错。</p>
</li>
</ul>
<h4 id="Mutex的-API"><a href="#Mutex的-API" class="headerlink" title="Mutex的 API"></a>Mutex<T>的 API</h4><ul>
<li>我们先从在单线程环境中使用互斥器开始，作为展示其用法的一个例子：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = m.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        *num = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;m = &#123;m:?&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>像很多类型一样，我们使用关联函数 new 来创建一个 Mutex<T>。使用 lock 方法来获取锁，从而可以访问互斥器中的数据。这个调用会阻塞当前线程，直到我们拥有锁为止。</p>
</li>
<li><p>如果另一个线程拥有锁，并且那个线程 panic 了，则 lock 调用会失败。在这种情况下，没人能够再获取锁，所以我们调用 unwrap，使当前线程 panic。</p>
</li>
<li><p>一旦获取了锁，就可以将返回值（命名为 num）视为一个其内部数据（i32）的可变引用了。类型系统确保了我们在使用 m 中的值之前获取锁。m 的类型是 Mutex<i32> 而不是 i32，所以 必须 获取锁才能使用这个 i32 值。我们是不会忘记这么做的，因为如果没有获取锁，类型系统就不允许访问内部的 i32 值。</p>
</li>
<li><p>正如你所猜想的，Mutex<T> 是一个智能指针。更准确的说，lock 调用 返回 一个叫做 MutexGuard 的智能指针。这个智能指针实现了 Deref 来指向其内部数据；它也实现了 Drop，当 MutexGuard 离开作用域时，自动释放锁（发生在示例 16-12 内部作用域的结尾）。有了这个特性，就不会有忘记释放锁的潜在风险（忘记释放锁会使互斥器无法再被其它线程使用），因为锁的释放是自动发生的。</p>
</li>
<li><p>释放锁之后，我们可以打印出互斥器内部的 i32 值，并发现我们刚刚已经将其值改为 6。</p>
</li>
</ul>
<h4 id="在线程间共享-Mutex"><a href="#在线程间共享-Mutex" class="headerlink" title="在线程间共享 Mutex"></a>在线程间共享 Mutex<T></h4><ul>
<li>现在让我们尝试使用 Mutex<T> 在多个线程间共享同一个值。我们将启动 10 个线程，并在各个线程中对同一个计数器值加 1，这样计数器将从 0 变为 10。示例 16-13 中的例子会出现编译错误，而我们将通过这些错误来学习如何使用 Mutex<T>，以及 Rust 又是如何帮助我们正确使用的。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>程序启动了 10 个线程，每个线程都通过 Mutex<T> 来增加计数器的值</p>
</li>
<li><p>这里创建了一个 counter 变量来存放内含 i32 的 Mutex<T>，类似示例 16-12 那样。接下来我们遍历整数区间，创建了 10 个线程。我们使用了 thread::spawn，并为所有线程传入了相同的闭包：它们每一个都将调用 lock 方法来获取 Mutex<T> 上的锁，接着将互斥器中的值加一。当一个线程结束执行，num 会离开闭包作用域并释放锁，这样另一个线程就可以获取它了。</p>
</li>
<li><p>在主线程中，我们像之前那样收集了所有的 JoinHandle，并调用它们的 join 方法来等待所有线程结束。然后，主线程会获取锁，并打印出程序的结果。</p>
</li>
</ul>
<p>这个例子不能编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling shared-state v0.1.0 (file:///projects/shared-state)</span><br><span class="line">error[E0382]: borrow of moved value: `counter`</span><br><span class="line">  --&gt; src/main.rs:21:29</span><br><span class="line">   |</span><br><span class="line">5  |     let counter = Mutex::new(0);</span><br><span class="line">   |         ------- move occurs because `counter` has type `Mutex&lt;i32&gt;`, which does not implement the `Copy` trait</span><br><span class="line">...</span><br><span class="line">8  |     for _ in 0..10 &#123;</span><br><span class="line">   |     -------------- inside of this loop</span><br><span class="line">9  |         let handle = thread::spawn(move || &#123;</span><br><span class="line">   |                                    ------- value moved into closure here, in previous iteration of loop</span><br><span class="line">...</span><br><span class="line">21 |     println!(&quot;Result: &#123;&#125;&quot;, *counter.lock().unwrap());</span><br><span class="line">   |                             ^^^^^^^ value borrowed here after move</span><br><span class="line">   |</span><br><span class="line">help: consider moving the expression out of the loop so it is only moved once</span><br><span class="line">   |</span><br><span class="line">8  ~     let mut value = counter.lock();</span><br><span class="line">9  ~     for _ in 0..10 &#123;</span><br><span class="line">10 |         let handle = thread::spawn(move || &#123;</span><br><span class="line">11 ~             let mut num = value.unwrap();</span><br><span class="line">   |</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0382`.</span><br><span class="line">error: could not compile `shared-state` (bin &quot;shared-state&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>
<ul>
<li>错误信息表明 counter 值在上一次循环中被移动了。所以 Rust 告诉我们，不能将 counter 锁的所有权移动到多个线程中。</li>
</ul>
<h4 id="多线程和多所有权"><a href="#多线程和多所有权" class="headerlink" title="多线程和多所有权"></a>多线程和多所有权</h4><ul>
<li>我们用智能指针 Rc<T> 来创建引用计数，使得一个值有了多个所有者。让我们做同样的事，看看会发生什么。将上面的 Mutex<T> 封装进 Rc<T> 中，并在将所有权移入线程之前克隆（clone） Rc<T>。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Rc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再一次编译,出现了不同的错误:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling shared-state v0.1.0 (file:///projects/shared-state)</span><br><span class="line">error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</span><br><span class="line">  --&gt; src/main.rs:11:36</span><br><span class="line">   |</span><br><span class="line">11 |           let handle = thread::spawn(move || &#123;</span><br><span class="line">   |                        ------------- ^------</span><br><span class="line">   |                        |             |</span><br><span class="line">   |  ______________________|_____________within this `&#123;closure@src/main.rs:11:36: 11:43&#125;`</span><br><span class="line">   | |                      |</span><br><span class="line">   | |                      required by a bound introduced by this call</span><br><span class="line">12 | |             let mut num = counter.lock().unwrap();</span><br><span class="line">13 | |</span><br><span class="line">14 | |             *num += 1;</span><br><span class="line">15 | |         &#125;);</span><br><span class="line">   | |_________^ `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</span><br><span class="line">   |</span><br><span class="line">   = help: within `&#123;closure@src/main.rs:11:36: 11:43&#125;`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`, which is required by `&#123;closure@src/main.rs:11:36: 11:43&#125;: Send`</span><br><span class="line">note: required because it&#x27;s used within this closure</span><br><span class="line">  --&gt; src/main.rs:11:36</span><br><span class="line">   |</span><br><span class="line">11 |         let handle = thread::spawn(move || &#123;</span><br><span class="line">   |                                    ^^^^^^^</span><br><span class="line">note: required by a bound in `spawn`</span><br><span class="line">  --&gt; /rustc/eeb90cda1969383f56a2637cbd3037bdf598841c/library/std/src/thread/mod.rs:688:1</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0277`.</span><br><span class="line">error: could not compile `shared-state` (bin &quot;shared-state&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>
<ul>
<li>第一行错误表明 Rc&lt;Mutex<i32>&gt; 不能在线程间安全传递（<code>Rc&lt;Mutex&lt;i32&gt;&gt;</code> cannot be sent between threads safely）；编译器也指出了原因：Rc&lt;Mutex<i32>&gt; 没有实现 Send trait（the trait <code>Send</code> is not implemented for <code>Rc&lt;Mutex&lt;i32&gt;&gt;</code>）。下一节我们会讲到 Send：这是一个确保所使用的类型可以用于并发环境的 trait。</li>
<li>不幸的是，Rc<T> 并不能安全的在线程间共享。当 Rc<T> 管理引用计数时，它必须在每一个 clone 调用时增加计数，并在每一个克隆体被丢弃时减少计数。Rc<T> 并没有使用任何并发原语，无法确保改变计数的操作不会被其他线程打断。这可能使计数出错，并导致诡异的 bug，比如可能会造成内存泄漏，或在使用结束之前就丢弃一个值。我们所需要的是一个与 Rc<T> 完全一致，又以线程安全的方式改变引用计数的类型。</li>
</ul>
<h4 id="原子引用计数-Arc"><a href="#原子引用计数-Arc" class="headerlink" title="原子引用计数 Arc"></a>原子引用计数 Arc<T></h4><p>所幸 Arc<T> 正是这么一个类似 Rc<T> 并可以安全的用于并发环境的类型。字母 “a” 代表 原子性（atomic），所以这是一个 原子引用计数（atomically reference counted）类型。原子类型 (Atomics) 是另一类这里还未涉及到的并发原语：请查看标准库中 std::sync::atomic 的文档来获取更多细节。目前我们只需要知道：原子类型就像基本类型一样，可以安全的在线程间共享。</p>
<ul>
<li><p>为什么不是所有的基本类型都是原子性的？为什么标准库中的类型没有全部默认使用 Arc<T> 实现？原因在于，线程安全会造成性能损失，我们希望只在必要时才为此买单。如果只是在单线程中对值进行操作，原子性提供的保证并无必要，而不加入原子性可以使代码运行得更快。</p>
</li>
<li><p>回到之前的例子：Arc<T> 和 Rc<T> 有着相同的 API，所以我们只需修改程序中的 use 行、new 调用和 clone 调用。</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会打印出：</p>
<blockquote>
<p>Result: 10</p>
</blockquote>
<ul>
<li>注意，对于简单的数值运算，标准库中 std::sync::atomic 模块 提供了比 Mutex<T> 更简单的类型。针对基本类型，这些类型提供了安全、并发、原子的操作。在上面的例子中，为了专注于讲明白 Mutex<T> 的用法，我们才选择在基本类型上使用 Mutex<T>。（译注：对于上面例子中出现的 i32 加法操作，更好的做法是使用 AtomicI32 类型来完成。具体参考文档。）</li>
</ul>
<h4 id="RefCell-Rc-与-Mutex-Arc-的相似性"><a href="#RefCell-Rc-与-Mutex-Arc-的相似性" class="headerlink" title="RefCell&#x2F;Rc 与 Mutex&#x2F;Arc 的相似性"></a>RefCell<T>&#x2F;Rc<T> 与 Mutex<T>&#x2F;Arc<T> 的相似性</h4><ul>
<li>尽管 counter 是不可变的，我们仍然可以获取其内部值的可变引用；这意味着 Mutex<T> 提供了内部可变性，就像 Cell 系列类型那样。使用 RefCell<T> 可以改变 Rc<T> 中内容，同样地，使用 Mutex<T> 我们也可以改变 Arc<T> 中的内容。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/11/twilveth/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kunqi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0xkunqil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/11/twilveth/" class="post-title-link" itemprop="url">Trait 特性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-11-11 11:11:47 / Modified: 19:34:31" itemprop="dateCreated datePublished" datetime="2024-11-11T11:11:47+08:00">2024-11-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li>trait 定义了某个特定类型拥有可能与其他类型共享的功能</li>
<li>trait 类似于其他语言中常被称为 接口（interface）的功能，虽然有一些差别</li>
</ul>
<h4 id="普通实现"><a href="#普通实现" class="headerlink" title="普通实现"></a>普通实现</h4><ul>
<li>使用 <code>trait</code> 关键字来声明一个特征</li>
<li><code>Summary</code> 是特征名</li>
<li>在大括号中定义了该特征的所有方法</li>
<li>只定义特征方法的签名，而不进行实现，此时方法签名结尾是<code>;</code>, 而不是一个<code>&#123;&#125;</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为类型实现特征</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> title: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;文章&#123;&#125;, 作者是&#123;&#125;&quot;</span>, <span class="keyword">self</span>.title, <span class="keyword">self</span>.author);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;发表了微博&#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="特征的定义与实现的位置（孤儿规则）"><a href="#特征的定义与实现的位置（孤儿规则）" class="headerlink" title="特征的定义与实现的位置（孤儿规则）"></a>特征的定义与实现的位置（孤儿规则）</h4><ul>
<li><p>如果你想要为类型<code>A</code>实现特征<code>T</code>，那么<code>A</code>或者<code>T</code>至少需要有一个是在当前作用域定义的</p>
</li>
<li><p>例如，可以为上面的<code>Post</code>类型实现标准库中的<code>Display</code>特征，这是因为<code>Post</code>定义在当前作用区域</p>
</li>
<li><p>可以在当前包中为<code>String</code>类型实现<code>Summary</code>特征，因为<code>Summary</code>定义在当前作用域中</p>
</li>
<li><p>无法在当前作用域中，为<code>String</code>类型实现<code>Display</code>特征，因为他们与当前作用域均无关联</p>
</li>
<li><p>定义一个<code>trait</code>的时候，我们还可以给<code>trait</code>加上一个默认方法：</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Read more ...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>此时如果我们对某个结构体应用一个特性的时候，不做任何的实现</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Post</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对Post来说，就会调用默认的方法，没有实现重载</p>
</li>
<li><p>另一方面，我们定义一个trait的时候，如果存在多个方法定义，可以互相调用，哪怕没有方法实现</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_authors</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Read the author summary &#123;:?&#125;&quot;</span>, summarize_authors)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="带泛形的trait"><a href="#带泛形的trait" class="headerlink" title="带泛形的trait"></a>带泛形的trait</h4><ul>
<li>在具体方法调用的时候，必须加以类型标注，以明确使用的是哪一个具体的实现</li>
<li>可以对同一个目标类型，多次 <code>impl</code> 此 <code>trait</code>，每次提供不同的泛形参数</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Converter</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">convert</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyInt</span>(<span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Converter</span>&lt;<span class="type">String</span>&gt; <span class="keyword">for</span> <span class="title class_">MyInt</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">convert</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Converter</span>&lt;<span class="type">f32</span>&gt; <span class="keyword">for</span> <span class="title class_">MyInt</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">convert</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span> <span class="keyword">as</span> <span class="type">f32</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_int</span> = <span class="title function_ invoke__">MyInt</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">output</span>: <span class="type">String</span> = my_int.<span class="title function_ invoke__">convert</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;output is: &#123;&#125;&quot;</span>, output);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">output</span>: <span class="type">f32</span> = my_int.<span class="title function_ invoke__">convert</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;output is: &#123;&#125;&quot;</span>, output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>以上例子中，使用的时候需要注意，要在定义变量的时候显式注明类型，不然编译器会报错</li>
<li>要注意 <code>方法的泛形</code> 和 <code>trait的泛形</code>的区别</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: <span class="built_in">Default</span>&gt; Convert&lt;T&gt; <span class="keyword">for</span> <span class="title class_">MyInt</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">convert</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">        T::<span class="title function_ invoke__">default</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个时候传递的就是方法的泛形而不是trait的泛形</li>
</ul>
<h4 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h4><ul>
<li><p>关联类型是trait定义中的类型占位符，定义的时候，并不定义它的具体类型是什么，在impl这个trait的时候才为这个关联类型赋予类型定义。</p>
</li>
<li><p>关联类型方式只允许对目标类型实现一次，也就是当你想trait只实现一种类型的时候，可以利用关联类型。</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Converter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">convert</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Converter</span> <span class="keyword">for</span> <span class="title class_">MyInt</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">convert</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="默认泛形类型参数"><a href="#默认泛形类型参数" class="headerlink" title="默认泛形类型参数"></a>默认泛形类型参数</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>&lt;T:std::ops::Add&lt;Output = T&gt;&gt;(a:T, b:T) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add i8: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">2i8</span>, <span class="number">2i8</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add i32: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add f64: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">1.23</span>, <span class="number">1.23</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>实现 Add trait 的时候不指定 Rhs 的具体类型，Rhs的类型将是默认的Self类型，也就是在其上实现Add的类型。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Add</span>&lt;Rhs = <span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, rhs: Rhs) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们以一个坐标轴点的坐标相加作为一个例子，实现一个Add的trait：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Point;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: Point) <span class="punctuation">-&gt;</span> Point &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x + other.x,</span><br><span class="line">            y: <span class="keyword">self</span>.y + other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果两个类型不同，想要相加，又该如何呢：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Millimeters</span>(<span class="type">u32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Meters</span>(<span class="type">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m1</span> = <span class="title function_ invoke__">Millimeters</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m2</span> = <span class="title function_ invoke__">Meters</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="title function_ invoke__">add</span>(m1, m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span>&lt;Meters&gt; <span class="keyword">for</span> <span class="title class_">Millimeters</span> &#123; </span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Millimeters;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: Meters) <span class="punctuation">-&gt;</span> Millimeters &#123;</span><br><span class="line">        <span class="title function_ invoke__">Millimeters</span>(<span class="keyword">self</span>.<span class="number">0</span> + other.<span class="number">0</span> * <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>&lt;T:std::ops::Add&lt;U,Output = T&gt;, U&gt;(a:T, b: U) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="impl-Trait-语法"><a href="#impl-Trait-语法" class="headerlink" title="impl Trait 语法"></a>impl Trait 语法</h4><ul>
<li>你可以使用任何实现了 Summary 特征的类型作为该函数的参数</li>
<li>除了单个约束条件，我们还可以通过 + 语法指定多个约束条件</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;(<span class="keyword">impl</span> <span class="title class_">Summary</span> + Display)) &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Trait-Bound-语法"><a href="#Trait-Bound-语法" class="headerlink" title="Trait Bound 语法"></a>Trait Bound 语法</h4><ul>
<li>impl Trait 适用于短小的例子，它是 trait bound语法的语法糖</li>
<li>更长的 trait bound则适用于更加复杂的场景</li>
<li>除了单个约束条件，我们还可以通过 + 语法指定多个约束条件</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item: &amp;T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display&gt;(item: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>由于此时存在泛形约束，在存在多个不同参数和签名的时候，例如：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display, U:Summary + Display&gt;(item1: &amp;T, item2: &amp;U) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>就会显得非常冗长</li>
<li>我们可以使用 <code>where</code> 关键字这个语法糖改写：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// where 语法简化 trait bound</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T, U&gt;(item1: &amp;T, item2: &amp;U) </span><br><span class="line">    <span class="keyword">where</span> </span><br><span class="line">        T: Summary + Display, </span><br><span class="line">        U:Summary + Display + <span class="built_in">Debug</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用trait-作为泛形的类型"><a href="#使用trait-作为泛形的类型" class="headerlink" title="使用trait 作为泛形的类型"></a>使用trait 作为泛形的类型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> &lt;T:Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp_display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;the larger one is x = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;the larger one is y = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.y)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 对于实现了Display和 PartialOrd的trait的数据而言，就可以使用 cmp_display方法</span></span><br></pre></td></tr></table></figure>

<h4 id="返回一个-trait-类型"><a href="#返回一个-trait-类型" class="headerlink" title="返回一个 trait 类型"></a>返回一个 trait 类型</h4><ul>
<li>类似作为参数的trait，返回值类型也可以返回一个trait类型</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">summarizable</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    Post &#123;</span><br><span class="line">        title: <span class="string">&quot;Summary&quot;</span>.to_string,</span><br><span class="line">        author: <span class="string">&quot;me&quot;</span>.to_string,</span><br><span class="line">        content: <span class="string">&quot;great&quot;</span>.to_string,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果我们要返回多个不同类型，但是都实现了 Summary trait的对象，直接这样写编译器会报错，因为编译器在编译期需要了解对返回对象分配多大的内存，所以如果不指定，就会报错</p>
</li>
<li><p>这个时候可以使用之前用过的Box智能指针</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">summarizable</span>(switch: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Summary&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> switch &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Post &#123;</span><br><span class="line">            title: <span class="string">&quot;Summary&quot;</span>.to_string,</span><br><span class="line">            author: <span class="string">&quot;me&quot;</span>.to_string,</span><br><span class="line">            content: <span class="string">&quot;great&quot;</span>.to_string,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Weibo &#123;</span><br><span class="line">            username: <span class="string">&quot;me&quot;</span>.to_string,</span><br><span class="line">            content: <span class="string">&quot;great&quot;</span>.to_string,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常用派生特征语法"><a href="#常用派生特征语法" class="headerlink" title="常用派生特征语法"></a>常用派生特征语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#[derivce(Debug)] // 格式化输出 &#123;:?&#125;</span><br><span class="line"></span><br><span class="line">#[derive(Default)] // </span><br><span class="line"></span><br><span class="line">#[derive(Debug, Default)] // 多个派生写法</span><br><span class="line"></span><br><span class="line">#[derive(Copy)] // 避免所有权移动</span><br></pre></td></tr></table></figure>

<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><ul>
<li><p>错误代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;fmt::Display, ops::Add, process::Output&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要改Item的定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要改Apple结构的定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Apple</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Item</span> <span class="keyword">for</span> <span class="title class_">Apple</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; </span><br><span class="line">        <span class="keyword">self</span>.name.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    author: <span class="type">String</span>,</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Item</span> <span class="keyword">for</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;@&#123;&#125;:&#123;&#125;&quot;</span>, <span class="keyword">self</span>.author, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    items: <span class="type">Vec</span>&lt;Item&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">iterator</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> <span class="keyword">self</span>.items &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">apple</span> = Apple &#123;</span><br><span class="line">        name: <span class="string">&quot;Apple&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = Weibo &#123;</span><br><span class="line">        author: <span class="string">&quot;Weibo&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        content: <span class="string">&quot;Hello, World!&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">container</span> = Container &#123;</span><br><span class="line">        items: <span class="built_in">vec!</span>[apple, w],</span><br><span class="line">    &#125;;</span><br><span class="line">    container.<span class="title function_ invoke__">iterator</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>改法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;fmt::Display, ops::Add, process::Output&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要改Item的定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要改Apple结构的定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Apple</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Item</span> <span class="keyword">for</span> <span class="title class_">Apple</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">String</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; </span><br><span class="line">        <span class="keyword">self</span>.name.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    author: <span class="type">String</span>,</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Item</span> <span class="keyword">for</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">String</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;@&#123;&#125;:&#123;&#125;&quot;</span>, <span class="keyword">self</span>.author, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    items: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Item&lt;Output = <span class="type">String</span>&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">iterator</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> &amp;<span class="keyword">self</span>.items &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">apple</span> = Apple &#123;</span><br><span class="line">        name: <span class="string">&quot;Apple&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = Weibo &#123;</span><br><span class="line">        author: <span class="string">&quot;Weibo&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        content: <span class="string">&quot;Hello, World!&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">container</span> = Container &#123;</span><br><span class="line">        items: <span class="built_in">vec!</span>[<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(apple), <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(w)],</span><br><span class="line">    &#125;;</span><br><span class="line">    container.<span class="title function_ invoke__">iterator</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/06/eleventh_chapter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kunqi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0xkunqil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/06/eleventh_chapter/" class="post-title-link" itemprop="url">Rust基础：生命周期</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-06 18:22:06" itemprop="dateCreated datePublished" datetime="2024-11-06T18:22:06+08:00">2024-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-07 23:37:37" itemprop="dateModified" datetime="2024-11-07T23:37:37+08:00">2024-11-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li><p>在Rust中，生命周期是用来解决借用的限制问题的。生命周期是指在程序运行时，某个值的有效范围。生命周期的作用是保证借用的值在借用结束之前有效。</p>
</li>
<li><p>有些值具有静态生命周期，它们会在整个程序运行期间一直有效。比如：</p>
</li>
</ul>
<ol>
<li>全局变量</li>
<li>静态变量</li>
<li>字符串字面量</li>
<li>函数指针</li>
<li>&amp;‘static T类型的引用</li>
<li>而其他的类型，比如局部变量，函数参数，函数返回值等，都是具有动态生命周期的，它们的生命周期是在函数调用时确定的。</li>
</ol>
<h3 id="生命周期参数"><a href="#生命周期参数" class="headerlink" title="生命周期参数"></a>生命周期参数</h3><ul>
<li>在Rust中，生命周期参数是用来描述引用的生命周期的，它的语法是’a，其中a是生命周期参数的名称，可以是任意的合法标识符。生命周期参数位于引用符号&amp;和引用的类型之间，比如：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="type">i32</span> <span class="comment">// 引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span> <span class="comment">// 标注生命周期参数的不可变引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">i32</span> <span class="comment">// 标注生命周期参数的可变引用</span></span><br></pre></td></tr></table></figure>
<ul>
<li>标注的生命周期参数只是用于编译器的借用检查。</li>
</ul>
<h3 id="生命周期消除（Lifetime-Elision）"><a href="#生命周期消除（Lifetime-Elision）" class="headerlink" title="生命周期消除（Lifetime Elision）"></a>生命周期消除（Lifetime Elision）</h3><ul>
<li>某些情况下，生命周期可以由Rust编译器自动推理，无需手动重复添加</li>
</ul>
<ol>
<li>每个引用参数都有自己的生命周期参数</li>
<li>如果只有一个输入引用参数，那么它的生命周期会被赋予所有输出引用。</li>
<li>如果有多个输入生命周期参数，但其中一个是<code>&amp;self</code>或<code>&amp;mut self</code>，那么 <code>self</code> 的生命周期会被赋予所有输出引用。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_world</span>(s: &amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    &amp;s[..<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">log</span>(a: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="type">str</span>, &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    (a, a)</span><br><span class="line">&#125; <span class="comment">// 以上情况，所有输出引用的生命周期都是输入引用的生命周期</span></span><br></pre></td></tr></table></figure>

<p>以一个例子完整了解一下生命周期问题：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test_lifetime_multiple</span>() &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">insert_value</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(my_vec: &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>&gt;, value: &amp;<span class="symbol">&#x27;b</span> <span class="type">i32</span>)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="symbol">&#x27;b</span>:<span class="symbol">&#x27;a</span></span><br><span class="line">    &#123;</span><br><span class="line">        my_vec.<span class="title function_ invoke__">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_vec</span>: <span class="type">Vec</span>&lt;&amp;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">val1</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">val2</span> = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">insert_value</span>(&amp;<span class="keyword">mut</span> my_vec, &amp;val1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;my_vec is &#123;:?&#125;&quot;</span>, my_vec);</span><br><span class="line">    <span class="title function_ invoke__">insert_value</span>(&amp;<span class="keyword">mut</span> my_vec, &amp;val2); <span class="comment">// 报借用冲突错误</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;my_vec is &#123;:?&#125;&quot;</span>, my_vec);</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;my_vec:?&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>对于上述代码，第二次调用insert_value时报错：cannot borrow <code>my_vec</code> as mutable more than once at a time， 这代表我们在同一时间存在多个统一变量的可变引用，造成所有权冲突。</p>
</li>
<li><p>这是因为，<code>my_vec</code>和<code>value</code>实际上生命周期一致，由于val1和val2的生命周期为<code>‘static</code>，所以<code>my_vec</code>的可变引用生命周期产生了外扩</p>
</li>
<li><p>这个时候，解决方式就是将<code>my_vec</code>的生命周期标注删除</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test_lifetime_multiple</span>() &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">insert_value</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(my_vec: &amp;<span class="keyword">mut</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>&gt;, value: &amp;<span class="symbol">&#x27;b</span> <span class="type">i32</span>)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="symbol">&#x27;b</span>:<span class="symbol">&#x27;a</span></span><br><span class="line">    &#123;</span><br><span class="line">        my_vec.<span class="title function_ invoke__">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_vec</span>: <span class="type">Vec</span>&lt;&amp;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">val1</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">val2</span> = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">insert_value</span>(&amp;<span class="keyword">mut</span> my_vec, &amp;val1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;my_vec is &#123;:?&#125;&quot;</span>, my_vec);</span><br><span class="line">    <span class="title function_ invoke__">insert_value</span>(&amp;<span class="keyword">mut</span> my_vec, &amp;val2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;my_vec is &#123;:?&#125;&quot;</span>, my_vec);</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;my_vec:?&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>此时，编译期将不再报冲突问题。</p>
</li>
<li><p>还有一种解决方式，就是利用RefCell的内部可变性解决：</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test_lifetime_multiple</span>() &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">insert_value</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(my_vec: &amp;<span class="symbol">&#x27;a</span> RefCell&lt;<span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>&gt;&gt;, value: &amp;<span class="symbol">&#x27;b</span> <span class="type">i32</span>)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="symbol">&#x27;b</span>:<span class="symbol">&#x27;a</span></span><br><span class="line">    &#123;</span><br><span class="line">        my_vec.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_vec</span> =RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">val1</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">val2</span> = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">insert_value</span>(&amp;my_vec, &amp;val1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;my_vec is &#123;:?&#125;&quot;</span>, my_vec.<span class="title function_ invoke__">borrow</span>());</span><br><span class="line">    <span class="title function_ invoke__">insert_value</span>(&amp;my_vec, &amp;val2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;my_vec is &#123;:?&#125;&quot;</span>, my_vec.<span class="title function_ invoke__">borrow</span>());</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;my_vec:?&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>由于其内部可变性，我们入参可以改为不可变引用，符合所有权借用的规则</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/03/tenth_chapter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kunqi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0xkunqil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/03/tenth_chapter/" class="post-title-link" itemprop="url">Rust基础：智能指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-03 23:09:01" itemprop="dateCreated datePublished" datetime="2024-11-03T23:09:01+08:00">2024-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-06 00:27:58" itemprop="dateModified" datetime="2024-11-06T00:27:58+08:00">2024-11-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><ul>
<li><p>智能指针是一类数据结构，它不仅包含一个指针，还附带一些额外的元数据和功能，与普通指针不同，智能指针还在Rust中实现了<code>Deref</code> 和 <code>Drop</code> 两个 trait，这使得它们可以像指针一样解引用，并且在离开作用域时自动清理资源。</p>
</li>
<li><p>存在智能指针的目的有以下几点：</p>
</li>
</ul>
<ol>
<li>资源管理：自动管理资源的分配与释放，避免内存泄漏。</li>
<li>所有权与借用：Rust所有权系统通过智能指针来确保内存安全，避免数据竞争和悬垂指针。</li>
<li>复杂数据结构：通过智能指针可以构建复杂的数据结构，如递归结构、共享数据等。</li>
</ol>
<ul>
<li>智能指针的特性</li>
</ul>
<ol>
<li>Deref trait： 实现了 Deref trait 的类型可以像常规引用一样使用<code>*</code>解引用</li>
<li>Drop trait：实现了 Drop trait 的类型在离开作用域时，会自动调用drop方法，用于释放资源</li>
</ol>
<h4 id="Box-指针"><a href="#Box-指针" class="headerlink" title="Box 指针"></a>Box<T> 指针</h4><ul>
<li><code>Box&lt;T&gt;</code> 将类型<code>T</code>的值分配在堆上而不是栈上。</li>
<li>当 <code>Box</code> 被销毁时，堆上的数据也会被销毁。</li>
</ul>
<ol>
<li>Box的底层原理：<code>Box&lt;T&gt;</code>实际上是一个智能指针，内部包含一个指向堆上分配内存的裸指针。</li>
</ol>
<ul>
<li>当其被销毁时，Drop trait 会被调用，释放堆上的内存。</li>
</ul>
<ol start="2">
<li>内存分配：Rust使用系统的全局分配器（如 malloc 和 free）来管理内存</li>
</ol>
<ul>
<li>Box::new 分配内存，Drop 释放内存</li>
</ul>
<ol start="3">
<li>安全性：Rust的所有权系统确保 <code>Box&lt;T&gt;</code> 的内存安全，所有权转移时，堆内存的生命周期也会随之变化。</li>
<li>Box 处理较大数据结构或数据结构大小在编译时不确定时尤为方便。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>: <span class="type">Box</span>&lt;<span class="type">str</span>&gt; = <span class="string">&quot;Hello, world&quot;</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s =  &#123;:?&#125;&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: <span class="type">Box</span>&lt;[<span class="type">i32</span>]&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="title function_ invoke__">into_boxed_slice</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;arr = &#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到 Box 允许处理动态大小类型，如 <code>str</code> 和 <code>[T]</code>。</li>
</ul>
<ol start="5">
<li>在Rust中，如果直接使用递归数据结构是不行的，因为编译的时候需要一个确定的内容</li>
</ol>
<ul>
<li>但是通过 Box 指针，可以实现递归</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list</span> = List::<span class="title function_ invoke__">Cons</span>(<span class="number">1</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(List::<span class="title function_ invoke__">Cons</span>(<span class="number">2</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(List::Nil))));</span><br><span class="line">&#125; <span class="comment">// 实现了一个链表结构</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>Box 的类型擦除</li>
</ol>
<ul>
<li><code>Box&lt;dyn Trait&gt;</code> 用于类型擦除，可以允许在运行时决定类型</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Animals</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">to_speak</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cat</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animals</span> <span class="keyword">for</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">to_speak</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;wow!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animals</span> <span class="keyword">for</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">to_speak</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;meow!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">animal</span>: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Animals&gt;&gt; = <span class="built_in">vec!</span>[<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Dog), <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Cat)];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">animal</span> <span class="keyword">in</span> animal.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        animal.<span class="title function_ invoke__">to_speak</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：wow! meow! </p>
</blockquote>
<ul>
<li>这里的<code>dyn</code>关键字声明了一个动态类型，所以向量中可以放置不同类型的结构体</li>
<li><code>dyn</code>用于实现一个动态分发的trait对象，允许在运行时决定具体类型</li>
</ul>
<ol start="7">
<li>内存管理和性能优化</li>
</ol>
<ul>
<li>通过使用Box，可以控制内存的分配和释放，从而优化性能和内存使用，例如，将大型数据结构放在堆上而不是栈上，减少栈的使用量，避免栈溢出。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">large_array</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>([<span class="number">0u8</span>;<span class="number">1_000_000</span>]);  </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Large array allocated on the heap: &quot;</span> + large_array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>分配效率比较</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::time::Instant;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">now</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_array</span>  = <span class="built_in">vec!</span>[<span class="number">100_000_000</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">end</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;After the big array creation, the time is &#123;:?&#125;&quot;</span>, end - now);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">now_2</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_box_array</span>:<span class="type">Box</span>&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt; = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[<span class="number">100_000_000</span>]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">end_2</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;After create big boxed array creation, the time is &#123;:?&#125;&quot;</span>, end_2 - now_2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：After the big array creation, the time is 18.791µs<br>After create big boxed array creation, the time is 541ns</p>
</blockquote>
<ul>
<li><p>可以看到分配在堆上的时间远小于分配在栈上的时间</p>
</li>
<li><p>Box 的优缺点：</p>
</li>
</ul>
<ol>
<li>优点：提供内存分配；支持复杂数据结构；内存安全；动态分配对象，实现类型擦除</li>
<li>缺点：不适合频繁分配和释放的场景</li>
</ol>
<h4 id="Drop、Deref-和-DerefMut"><a href="#Drop、Deref-和-DerefMut" class="headerlink" title="Drop、Deref 和 DerefMut"></a>Drop、Deref 和 DerefMut</h4><ul>
<li>Drop trait: 定义了当一个值离开作用域时应该执行的操作，通常用于释放资源（内存，文件句柄，网络连接）。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Resources</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">Resources</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;resouces &#123;:?&#125; has been dropped&quot;</span>, <span class="keyword">self</span>.name);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res1</span> = Resources &#123;name: <span class="string">&quot;resouces1&quot;</span>.<span class="title function_ invoke__">to_string</span>()&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res2</span> = Resources &#123;name: <span class="string">&quot;resouces2&quot;</span>.<span class="title function_ invoke__">to_string</span>()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>离开作用域时，drop被调用</p>
<blockquote>
<p>输出：resouces “resouces2” has been dropped<br>resouces “resouces1” has been dropped</p>
</blockquote>
</li>
<li><p>trait的实现如下</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Drop</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Deref trait：定义了如何将一个类型转换为引用，用于重载解引用运算符<code>*</code>，它允许你定义自定义指针类型的解引用行为。该trait定义了一个deref方法，该方法返回指向目标类型的引用。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Deref</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span>: ?sized; <span class="comment">// ?sized 表示可以持有动态大小类型</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref; <span class="comment">// Deref trait在标准库中的ops库里</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt; (T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(value: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;deref is called.&quot;</span>);</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = MyBox::<span class="title function_ invoke__">new</span>(x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y is: &#123;&#125;&quot;</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：x is: 5<br>deref is called.<br>y is: 5  </p>
</blockquote>
<ul>
<li><p>我们可以看到，解引用被调用</p>
</li>
<li><p>DerefMut trait: 与Deref类似，DerefMut用于重载可变解引用运算符，允许对自定义类型进行可变解引用。</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">DerefMut</span>: Deref &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> <span class="keyword">Self</span>::Target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现可变解引用</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; DerefMut <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> T &#123;</span><br><span class="line">        <span class="title function_ invoke__">println</span>(<span class="string">&quot;DerefMut has been called&quot;</span>);</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Rc"><a href="#Rc" class="headerlink" title="Rc"></a>Rc<T></h4><ul>
<li><p>Rc 是 Reference Counted 的缩写，引用计数指针，是一个允许多所有者的共享所有权模型</p>
</li>
<li><p>它可以统计有多少个有效引用，当有效引用为0的时候，数据就可以被清理掉</p>
</li>
<li><p>举例说明<br><img src="/image.png" alt="alt text"></p>
</li>
</ul>
<ol>
<li>使用生命周期引用：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, &amp;<span class="symbol">&#x27;a</span> List&lt;<span class="symbol">&#x27;a</span>&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">study</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>:List = <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, &amp;List::<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>,&amp;Nil));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>:List = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, &amp;a);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span>:List = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, &amp;a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">study</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：Cons(5, Cons(10, Nil))<br>Cons(3, Cons(5, Cons(10, Nil)))<br>Cons(4, Cons(5, Cons(10, Nil)))  </p>
</blockquote>
<ol start="2">
<li>使用Rc<T>实现：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">study</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a)));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a)));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">study</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：Cons(5, Cons(10, Nil))<br>Cons(3, Cons(5, Cons(10, Nil)))<br>Cons(4, Cons(5, Cons(10, Nil)))</p>
</blockquote>
</li>
</ol>
<ul>
<li><p>我们也可以打印出引用计数看看：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">study</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a)));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a)));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：1<br>2<br>3  </p>
</blockquote>
</li>
<li><p>说明引用次数依次增加，当study函数作用域结束，所有引用将被释放。</p>
</li>
</ul>
<h4 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell"></a>RefCell<T></h4><ul>
<li>RefCell<T> 是 Rust 标准库中的一个智能指针类型，它提供了内部可变性，允许在不可变引用的情况下去修改数据。这种特性使得你可以在编译时保证安全的情况下动态地借用和修改数据。</li>
</ul>
<ol>
<li><p>内部可变性：<code>RefCell&lt;T&gt;</code> 允许你在其内部的 <code>T</code> 中进行修改，即使<code>RefCell&lt;T&gt;</code>本身是不可变的，这是通过借用检查实现的。</p>
</li>
<li><p>运行时借用检查：<code>RefCell</code> 使用运行时借用检查，确保在运行时遵循Rust的借用规则，即只允许同时存在一个可变借用或者多个不可变借用，编译时不会产生借用检查，如果出现借用冲突，会panic！。</p>
</li>
<li><p>borrow 和 borrow_mut 方法：提供了两个方法，borrow()获取多个不可变借用（Ref<T>）, borrow_mut() 获取一个可变借用（RefMut<T>）。</p>
</li>
<li><p>与 Cell 用于可 Copy 的值不同，RefCell 用于引用；RefCell 只是将借用规则从编译期推迟到程序运行期，并不能帮你绕过这个规则；RefCell 适用于编译期误报或者一个引用被在多处代码使用、修改以至于难于管理借用关系时。</p>
</li>
</ol>
<ul>
<li>使用场景：受限于所有权系统，需要共享且修改数据（树，图），主要用于单线程环境</li>
</ul>
<h4 id="Rc-RefCell-组合使用"><a href="#Rc-RefCell-组合使用" class="headerlink" title="Rc + RefCell 组合使用"></a>Rc + RefCell 组合使用</h4><ul>
<li>在 Rust 中，一个常见的组合就是 Rc 和 RefCell 在一起使用，前者可以实现一个数据拥有多个所有者，后者可以实现数据的可变性：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="string">&quot;我很善变，还拥有多个主人&quot;</span>.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="comment">// let mut s2 = s.borrow_mut();</span></span><br><span class="line">    s2.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, oh yeah!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;\n&#123;:?&#125;\n&#123;:?&#125;&quot;</span>, s, s1, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：RefCell { value: “我很善变，还拥有多个主人, oh yeah!” }<br>RefCell { value: “我很善变，还拥有多个主人, oh yeah!” }<br>RefCell { value: “我很善变，还拥有多个主人, oh yeah!” }  </p>
</blockquote>
<ul>
<li><p>上面代码中，我们使用 RefCell<String> 包裹一个字符串，同时通过 Rc 创建了它的三个所有者：s、s1和s2，并且通过其中一个所有者 s2 对字符串内容进行了修改。</p>
</li>
<li><p>由于 Rc 的所有者们共享同一个底层的数据，因此当一个所有者修改了数据时，会导致全部所有者持有的数据都发生了变化。</p>
</li>
</ul>
<h4 id="引用循环和内存泄漏"><a href="#引用循环和内存泄漏" class="headerlink" title="引用循环和内存泄漏"></a>引用循环和内存泄漏</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::&#123;Ref, RefCell&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    next:<span class="type">Option</span>&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(Node &#123; value: <span class="number">1</span>, next: <span class="literal">None</span>&#125;));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(Node &#123; value: <span class="number">2</span>, next: <span class="literal">None</span>&#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建引用循环</span></span><br><span class="line"></span><br><span class="line">    first.<span class="title function_ invoke__">borrow_mut</span>().next = <span class="title function_ invoke__">Some</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;second));</span><br><span class="line">    second.<span class="title function_ invoke__">borrow_mut</span>().next = <span class="title function_ invoke__">Some</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;first));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;first strong count :&#123;:?&#125; and first weak count: &#123;:?&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;first), Rc::<span class="title function_ invoke__">weak_count</span>(&amp;first));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;second strong count :&#123;:?&#125; and second weak count: &#123;:?&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;second), Rc::<span class="title function_ invoke__">weak_count</span>(&amp;second));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, first);  <span class="comment">// 发生 stackoverflow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：…..省略重复 { value: 1, next: Some(RefCell { value: Node { value: 2, next: Some(RefCell { value: Node { value: 1, next: Some(RefCell { value: Node { value: 2, next: Some(RefCell { value: Node { value: 1, next: Some(RefCell { value: Node { value: 2, next: Some(RefCell { value: Node { value: 1, next: Some(RefCell { value: Node { value: 2, next: Some(RefCell { value: Node { value: 1, next: Some(RefCell { value: Node { value: 2, next: Some(RefCell { value: Node { value: 1, next: Some(RefCell { value: Node { value: 2, next: Some(RefCell { value: Node { value: 1, next: Some(RefCell { value: Node { value: 2, next: Some(RefCell { value: Node { value: 1, next: Some(RefCell { value: Node { value: 2, next: Some(RefCell { value: Node { value: 1, next: Some(RefCell { value: Node { value: 2<br>thread ‘main’ has overflowed its stack<br>fatal runtime error: stack overflow  </p>
</blockquote>
<ul>
<li>栈溢出了</li>
</ul>
<h4 id="Weak"><a href="#Weak" class="headerlink" title="Weak"></a>Weak<T></h4><ul>
<li>非所有权引用，不影响<code>Rc&lt;T&gt;</code>的引用计数</li>
<li>避免了引用循环问题，不会引发内存泄漏</li>
<li>必须升级，由于它是一个非所有权引用，在使用数据前，必须通过<code>upgrade()</code>来升级成为<code>Rc&lt;T&gt;</code>，如果数据已经被释放，则<code>upgrade()</code>返回<code>None</code>。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::&#123;Rc, Weak&#125;;</span><br><span class="line"><span class="keyword">use</span> std::cell::&#123;Ref, RefCell&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    next:<span class="type">Option</span>&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,</span><br><span class="line">    prev: <span class="type">Option</span>&lt;Weak&lt;RefCell&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(Node &#123; value: <span class="number">1</span>, next: <span class="literal">None</span>, prev: <span class="literal">None</span> &#125;));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(Node &#123; value: <span class="number">2</span>, next: <span class="literal">None</span>, prev: <span class="literal">None</span> &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建引用循环</span></span><br><span class="line"></span><br><span class="line">    first.<span class="title function_ invoke__">borrow_mut</span>().next = <span class="title function_ invoke__">Some</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;second));</span><br><span class="line">    second.<span class="title function_ invoke__">borrow_mut</span>().prev = <span class="title function_ invoke__">Some</span>(Rc::<span class="title function_ invoke__">downgrade</span>(&amp;first)); <span class="comment">// 弱引用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;first strong count :&#123;:?&#125; and first weak count: &#123;:?&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;first), Rc::<span class="title function_ invoke__">weak_count</span>(&amp;first));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;second strong count :&#123;:?&#125; and second weak count: &#123;:?&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;second), Rc::<span class="title function_ invoke__">weak_count</span>(&amp;second));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, first);  <span class="comment">// 发生 stackoverflow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出： first strong count :1 and first weak count: 1<br>second strong count :2 and second weak count: 0<br>RefCell { value: Node { value: 1, next: Some(RefCell { value: Node { value: 2, next: None, prev: Some((Weak)) } }), prev: None } }  </p>
</blockquote>
<ul>
<li>解决引用循环的问题</li>
</ul>
<h4 id="强引用和弱引用的主要区别"><a href="#强引用和弱引用的主要区别" class="headerlink" title="强引用和弱引用的主要区别"></a>强引用和弱引用的主要区别</h4><ol>
<li><p>所有权：强引用 <code>Rc&lt;T&gt;</code> 持有数据的所有权，保证数据在作用域内不被释放；弱引用<code>Weak&lt;T&gt;</code>不持有数据的所有权，不影响数据的生命周期。</p>
</li>
<li><p>引用计数：强引用增加引用计数，数据被多个所有者共享；弱引用不增加引用计数，不干扰<code>Rc&lt;T&gt;</code>的生命周期管理。</p>
</li>
<li><p>内存管理：强引用只有当所有强引用都被丢弃时，数据才会被释放；弱引用只能通过升级<code>upgrade()</code>来访问数据，如果数据已经被释放，则升级会失败。</p>
</li>
<li><p>适用场景：强引用当你希望共享数据并确保数据至少有一个强引用存在时不被释放；弱引用当你需要避免引用循环，或只需要偶尔访问数据，不想持有所有权时。</p>
</li>
</ol>
<h4 id="社交网络系统例子"><a href="#社交网络系统例子" class="headerlink" title="社交网络系统例子"></a>社交网络系统例子</h4><p><img src="/image-1.png" alt="alt text"></p>
<ul>
<li>如何实现：</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/03/nineth_chapter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kunqi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0xkunqil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/03/nineth_chapter/" class="post-title-link" itemprop="url">Rust基础：模块化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-11-03 00:29:41 / Modified: 18:32:19" itemprop="dateCreated datePublished" datetime="2024-11-03T00:29:41+08:00">2024-11-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-模块化"><a href="#1-模块化" class="headerlink" title="1. 模块化"></a>1. 模块化</h3><ul>
<li>当工程规模变大时，把代码写到一个甚至几个文件中，都是不太聪明的做法，可能存在以下问题：</li>
</ul>
<ol>
<li>单个文件过大，导致打开、翻页速度大幅变慢</li>
<li>查询和定位效率大幅降低，类比下，你会把所有知识内容放在一个几十万字的文档中吗？</li>
<li>只有一个代码层次：函数，难以维护和协作，想象一下你的操作系统只有一个根目录，剩下的都是单层子目录会如何：disaster!容易滋生 Bug</li>
<li>同时，将大的代码文件拆分成包和模块，还允许我们实现代码抽象和复用：将你的代码封装好后提供给用户，那么用户只需要调用公共接口即可，无需知道内部该如何实现。</li>
</ol>
<ul>
<li>因此，跟其它语言一样，Rust 也提供了相应概念用于代码的组织管理：</li>
</ul>
<ol>
<li>项目(Packages)：一个 Cargo 提供的 feature，可以用来构建、测试和分享包</li>
<li>包(Crate)：一个由多个模块组成的树形结构，可以作为三方库进行分发，也可以生成可执行文件进行运行</li>
<li>模块(Module)：可以一个文件多个模块，也可以一个文件一个模块，模块可以被认为是真实项目中的代码组织单元</li>
</ol>
<ul>
<li>其实项目 Package 和包 Crate 很容易被搞混，甚至在很多书中，这两者都是不分的，但是由于官方对此做了明确的区分，因此我们会在本章节中试图（挣扎着）理清这个概念。</li>
</ul>
<h4 id="1-1-包-Crate"><a href="#1-1-包-Crate" class="headerlink" title="1.1 包 Crate"></a>1.1 包 Crate</h4><ul>
<li><p>对于 Rust 而言，包是一个独立的可编译单元，它编译后会生成一个可执行文件或者一个库。</p>
</li>
<li><p>一个包会将相关联的功能打包在一起，使得该功能可以很方便的在多个项目中分享。例如标准库中没有提供但是在三方库中提供的 rand 包，它提供了随机数生成的功能，我们只需要将该包通过 use rand; 引入到当前项目的作用域中，就可以在项目中使用 rand 的功能：rand::XXX。</p>
</li>
<li><p>同一个包中不能有同名的类型，但是在不同包中就可以。例如，虽然 rand 包中，有一个 Rng 特征，可是我们依然可以在自己的项目中定义一个 Rng，前者通过 rand::Rng 访问，后者通过 Rng 访问，对于编译器而言，这两者的边界非常清晰，不会存在引用歧义。</p>
</li>
</ul>
<h4 id="1-2-项目-Package"><a href="#1-2-项目-Package" class="headerlink" title="1.2 项目 Package"></a>1.2 项目 Package</h4><ul>
<li><p>鉴于 Rust 团队标新立异的起名传统，以及包的名称被 crate 占用，库的名称被 library 占用，经过斟酌， 我们决定将 Package 翻译成项目，你也可以理解为工程、软件包。</p>
</li>
<li><p>由于 Package 就是一个项目，因此它包含有独立的 Cargo.toml 文件，以及因为功能性被组织在一起的一个或多个包。一个 Package 只能包含一个库(library)类型的包，但是可以包含多个二进制可执行类型的包。</p>
</li>
</ul>
<ol>
<li>二进制package：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new my-project</span><br><span class="line">     Created <span class="title function_ invoke__">binary</span> (application) `my-project` package</span><br><span class="line">$ ls my-project</span><br><span class="line">Cargo.toml</span><br><span class="line">src</span><br><span class="line">$ ls my-project/src</span><br><span class="line">main.rs</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>这里，<code>Cargo</code> 为我们创建了一个名称是 <code>my-project</code> 的 Package，同时在其中创建了 <code>Cargo.toml</code> 文件，可以看一下该文件，里面并没有提到 src&#x2F;main.rs 作为程序的入口，原因是 Cargo 有一个惯例：<code>src/main.rs</code> 是二进制包的根文件，该二进制包的包名跟所属 Package 相同，在这里都是 <code>my-project</code>，所有的代码执行都从该文件中的 <code>fn main()</code> 函数开始。</li>
</ul>
<blockquote>
<p>使用 cargo run 可以运行该项目，输出：Hello, world!。</p>
</blockquote>
<ol start="2">
<li>库package：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new my-lib --lib</span><br><span class="line">     Created library `my-lib` package</span><br><span class="line">$ ls my-lib</span><br><span class="line">Cargo.toml</span><br><span class="line">src</span><br><span class="line">$ ls my-lib/src</span><br><span class="line">lib.rs</span><br></pre></td></tr></table></figure>

<ul>
<li><p>不能直接运行：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">error: a bin target must be available <span class="keyword">for</span> `cargo run`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>典型工程结构</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">├── Cargo.toml</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── src</span><br><span class="line">│   ├── main.rs</span><br><span class="line">│   ├── lib.rs</span><br><span class="line">│   └── bin</span><br><span class="line">│       └── main1.rs</span><br><span class="line">│       └── main2.rs</span><br><span class="line">├── tests</span><br><span class="line">│   └── some_integration_tests.rs</span><br><span class="line">├── benches</span><br><span class="line">│   └── simple_bench.rs</span><br><span class="line">└── examples</span><br><span class="line">    └── simple_example.rs</span><br></pre></td></tr></table></figure>

<ul>
<li>唯一库包：src&#x2F;lib.rs</li>
<li>默认二进制包：src&#x2F;main.rs，编译后生成的可执行文件与 Package 同名</li>
<li>其余二进制包：src&#x2F;bin&#x2F;main1.rs 和 src&#x2F;bin&#x2F;main2.rs，它们会分别生成一个文件同名的二- 进制可执行文件</li>
<li>集成测试文件：tests 目录下</li>
<li>基准性能测试 benchmark 文件：benches 目录下</li>
<li>项目示例：examples 目录下</li>
</ul>
<h4 id="1-3-模块-Modules"><a href="#1-3-模块-Modules" class="headerlink" title="1.3 模块 Modules"></a>1.3 模块 Modules</h4><ul>
<li><p>pub</p>
</li>
<li><p>mod</p>
</li>
<li><p>use</p>
</li>
<li><p>as</p>
</li>
<li><p>创建一个嵌套模块：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 餐厅前厅，用于吃饭</span></span><br><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_payment</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>以上的代码创建了三个模块，有几点需要注意的：</p>
</li>
</ul>
<ol>
<li>使用 mod 关键字来创建新模块，后面紧跟着模块名称</li>
<li>模块可以嵌套，这里嵌套的原因是招待客人和服务都发生在前厅，因此我们的代码模拟了真实场景</li>
<li>模块中可以定义各种 Rust 类型，例如函数、结构体、枚举、特征等</li>
<li>所有模块均定义在同一个文件中</li>
<li>类似上述代码中所做的，使用模块，我们就能将功能相关的代码组织到一起，然后通过一个模块名称来说明这些代码为何被组织在一起。这样其它程序员在使用你的模块时，就可以更快地理解和上手。</li>
</ol>
<h4 id="1-4-路径"><a href="#1-4-路径" class="headerlink" title="1.4 路径"></a>1.4 路径</h4><ul>
<li><p>Rust当中路径访问使用<code>::</code>来访问</p>
</li>
<li><p>Rust当中所有的定义默认是私有的，只有在模块内可以被访问，如果需要在外部使用，可以加上<code>pub</code>关键字</p>
</li>
<li><p>绝对路径访问：<code>crate::front_of_house::hosting::add_to_waitlist()</code></p>
</li>
<li><p>相对路径访问：<code>super::add_to_waitlist()</code></p>
</li>
<li><p><code>super</code> 关键字可以跳转到上一级模块</p>
</li>
<li><p>相对路径可以用<code>self</code>来表示当前模块，<code>super</code>来表示上一级模块</p>
</li>
</ul>
<h4 id="1-5-使用-use-关键字来引入模块"><a href="#1-5-使用-use-关键字来引入模块" class="headerlink" title="1.5 使用 use 关键字来引入模块"></a>1.5 使用 use 关键字来引入模块</h4><ul>
<li>如果模块存在嵌套，访问子模块内方法时需要逐级使用<code>::</code>，且方法需要定义为public</li>
<li>由于每次访问都需要逐级访问，我们可以用<code>use</code>来简化路径:类似alias</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::serving;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果a模块有一个方法，子模块b也有一个方法，两个方法是同名方法，以log()为例，可以用<code>as</code>来重新定义方法名</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> a::&#123;b::log <span class="keyword">as</span> log2, log&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>同时 <code>as</code>也可以作为类型转换语句</li>
</ul>
<h4 id="1-6-模块可见性"><a href="#1-6-模块可见性" class="headerlink" title="1.6 模块可见性"></a>1.6 模块可见性</h4><ul>
<li>private（default）</li>
<li>pub(crate)</li>
<li>pub(in path)</li>
<li>pub use</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">in</span> crate::front_of_house) <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>只有在 crate::front_of_house 路径下可以访问 seat_at_table() 方法</li>
<li>pub use 关键字可以将模块中的项公开到外面</li>
</ul>
<h4 id="1-7-workspace"><a href="#1-7-workspace" class="headerlink" title="1.7 workspace"></a>1.7 workspace</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Cargo.toml</span><br><span class="line">[workspace]</span><br><span class="line">members = [</span><br><span class="line">    &quot;my-project&quot;,</span><br><span class="line">    &quot;my-lib&quot;,</span><br><span class="line">    &quot;my-lib/my-sublib&quot;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li>Cargo.toml 里面的 members 是一个数组，包含了需要构建的多个 Package。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/02/eighth_chapter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kunqi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0xkunqil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/02/eighth_chapter/" class="post-title-link" itemprop="url">Rust基础：返回值与错误处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-02 22:21:48" itemprop="dateCreated datePublished" datetime="2024-11-02T22:21:48+08:00">2024-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-03 00:26:13" itemprop="dateModified" datetime="2024-11-03T00:26:13+08:00">2024-11-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一、返回值"><a href="#一、返回值" class="headerlink" title="一、返回值"></a>一、返回值</h3><ul>
<li><p>Rust 是一个类型安全的语言，这意味着返回值是由返回值类型来决定的。</p>
</li>
<li><p>Rust 的返回值可以是任何类型，包括 <code>()</code> 空元组，或者是其他任何类型。</p>
</li>
</ul>
<h4 id="1-解构Option"><a href="#1-解构Option" class="headerlink" title="1. 解构Option&lt;T&gt;"></a>1. 解构<code>Option&lt;T&gt;</code></h4><ol>
<li>如果 <code>Option&lt;T&gt;</code> 包含值，返回包含的值。</li>
<li>如果 <code>Option&lt;T&gt;</code> 包含 <code>None</code>，返回 <code>None</code> 值。</li>
</ol>
<ul>
<li>一个变量要么有值，要么为空</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">six</span> = <span class="title function_ invoke__">plus_one</span>(five);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">none</span> = <span class="title function_ invoke__">plus_one</span>(<span class="literal">None</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>plus_one 接受一个 <code>Option&lt;i32&gt;</code> 类型的参数，同时返回一个 <code>Option&lt;i32&gt; </code>类型的值（这种形式的函数在标准库内随处所见），在该函数的内部处理中，如果传入的是一个<code> None</code> ，则返回一个 None 且不做任何处理；如果传入的是一个 <code>Some(i32)</code>，则通过模式绑定，把其中的值绑定到变量 <code>i</code> 上，然后返回 <code>i+1</code> 的值，同时用 <code>Some </code>进行包裹。</li>
</ul>
<h5 id="1-1-Option-的一些辅助函数"><a href="#1-1-Option-的一些辅助函数" class="headerlink" title="1.1 Option&lt;T&gt; 的一些辅助函数"></a>1.1 <code>Option&lt;T&gt;</code> 的一些辅助函数</h5><ol>
<li><code>unwrap</code>：返回 <code>Option&lt;T&gt;</code> 包含的值，如果 <code>Option&lt;T&gt;</code> 为空，返回 <code>panic</code>。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = s.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 返回Option&lt;char&gt;</span></span><br><span class="line">    <span class="comment">// 如果能够明确值存在，可以使用unwrap()</span></span><br><span class="line">    <span class="comment">// 有值的时候会取值，没值的时候panic</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p1); <span class="comment">// 输出 ‘o’</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用<code>is_some</code> 和 <code>is_none</code> ：返回 <code>bool</code> 值，判断 <code>Option&lt;T&gt;</code> 包含值或者为空。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];</span><br><span class="line">    <span class="keyword">if</span> v.<span class="title function_ invoke__">get</span>(<span class="number">1</span>).<span class="title function_ invoke__">is_some</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value at index 1 is: &#123;&#125;&quot;</span>, v[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>unwrap_or</code> ：返回 <code>Option&lt;T&gt;</code> 包含的值，如果 <code>Option&lt;T&gt;</code> 为空，返回一个提供的默认值</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">div</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">f64</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> b != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(a <span class="keyword">as</span> <span class="type">f64</span> / b <span class="keyword">as</span> <span class="type">f64</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">div</span>(a, b).<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0.0</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出 0.0</p>
</blockquote>
<h3 id="二、错误处理"><a href="#二、错误处理" class="headerlink" title="二、错误处理"></a>二、错误处理</h3><ul>
<li><p>错误对于软件来说是不可避免的，因此一门优秀的编程语言必须有其完整的错误处理哲学。在很多情况下，Rust 需要你承认自己的代码可能会出错，并提前采取行动，来处理这些错误。</p>
</li>
<li><p>Rust 中的错误主要分为两类：</p>
</li>
</ul>
<ol>
<li>可恢复错误，通常用于从系统全局角度来看可以接受的错误，例如处理用户的访问、操作等错误，这些错误只会影响某个用户自身的操作进程，而不会对系统的全局稳定性产生影响</li>
<li>不可恢复错误，刚好相反，该错误通常是全局性或者系统性的错误，例如数组越界访问，系统启动时发生了影响启动流程的错误等等，这些错误的影响往往对于系统来说是致命的</li>
</ol>
<ul>
<li>很多编程语言，并不会区分这些错误，而是直接采用异常的方式去处理。Rust 没有异常，但是 Rust 也有自己的卧龙凤雏：<code>Result&lt;T, E&gt; </code>用于可恢复错误，<code>panic! </code>用于不可恢复错误。</li>
</ul>
<h4 id="1-panic！"><a href="#1-panic！" class="headerlink" title="1. panic！"></a>1. panic！</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    v[<span class="number">99</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在上面的代码中，Rust 编译器会在 <code>v[99]</code> 这行代码中 panic，并在 panic 发生时终止程序。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling panic v0.<span class="number">1.0</span> (file:<span class="comment">///projects/panic)</span></span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.27</span>s</span><br><span class="line">     Running `target/debug/panic`</span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;index</span> out of bounds: the len is <span class="number">3</span> but the index is <span class="number">99</span>&#x27;, src/main.rs:<span class="number">4</span>:<span class="number">5</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="1-1-主动调用"><a href="#1-1-主动调用" class="headerlink" title="1.1 主动调用"></a>1.1 主动调用</h5><ol>
<li><code>panic!</code> ：在代码中主动 panic，可以传递一个字符串作为 panic 的消息。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;crash and burn&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行后输出:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;crash</span> and burn&#x27;, src/main.rs:<span class="number">2</span>:<span class="number">5</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>RUST_BACKTRACE=1 cargo run</code>，可以看调用栈</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;index</span> out of bounds: the len is <span class="number">3</span> but the index is <span class="number">99</span>&#x27;, src/main.rs:<span class="number">4</span>:<span class="number">5</span></span><br><span class="line">stack backtrace:</span><br><span class="line">   <span class="number">0</span>: rust_begin_unwind</span><br><span class="line">             at /rustc/<span class="number">59</span>eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/std/src/panicking.rs:<span class="number">517</span>:<span class="number">5</span></span><br><span class="line">   <span class="number">1</span>: core::panicking::panic_fmt</span><br><span class="line">             at /rustc/<span class="number">59</span>eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:<span class="number">101</span>:<span class="number">14</span></span><br><span class="line">   <span class="number">2</span>: core::panicking::panic_bounds_check</span><br><span class="line">             at /rustc/<span class="number">59</span>eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:<span class="number">77</span>:<span class="number">5</span></span><br><span class="line">   <span class="number">3</span>: &lt;<span class="type">usize</span> <span class="keyword">as</span> core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index</span><br><span class="line">             at /rustc/<span class="number">59</span>eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:<span class="number">184</span>:<span class="number">10</span></span><br><span class="line">   <span class="number">4</span>: core::slice::index::&lt;<span class="keyword">impl</span> <span class="title class_">core</span>::ops::index::Index&lt;I&gt; <span class="keyword">for</span> [T]&gt;::index</span><br><span class="line">             at /rustc/<span class="number">59</span>eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:<span class="number">15</span>:<span class="number">9</span></span><br><span class="line">   <span class="number">5</span>: &lt;alloc::vec::<span class="type">Vec</span>&lt;T,A&gt; <span class="keyword">as</span> core::ops::index::Index&lt;I&gt;&gt;::index</span><br><span class="line">             at /rustc/<span class="number">59</span>eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/alloc/src/vec/<span class="keyword">mod</span>.rs:<span class="number">2465</span>:<span class="number">9</span></span><br><span class="line">   <span class="number">6</span>: world_hello::main</span><br><span class="line">             at ./src/main.rs:<span class="number">4</span>:<span class="number">5</span></span><br><span class="line">   <span class="number">7</span>: core::ops::function::<span class="built_in">FnOnce</span>::call_once</span><br><span class="line">             at /rustc/<span class="number">59</span>eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/ops/function.rs:<span class="number">227</span>:<span class="number">5</span></span><br><span class="line">note: <span class="literal">Some</span> details are omitted, run with `RUST_BACKTRACE=full` <span class="keyword">for</span> <span class="title class_">a</span> verbose backtrace.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>它包含了函数调用的顺序，当然按照逆序排列：最近调用的函数排在列表的最上方</li>
</ul>
<h4 id="2-Result"><a href="#2-Result" class="headerlink" title="2. Result&lt;T, E&gt;"></a>2. Result&lt;T, E&gt;</h4><ul>
<li>Result 是一个枚举，可以是 Ok(T)，也可以是 Err(E)。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们举一个例子</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">div</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">f64</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> b != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(a <span class="keyword">as</span> <span class="type">f64</span> / b <span class="keyword">as</span> <span class="type">f64</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="string">&quot;b cannot be zero&quot;</span>.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sqrt</span>(x: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">f64</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="string">&quot;x cannot be negative&quot;</span>.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(x.<span class="title function_ invoke__">sqrt</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们还可以定义错误的枚举类型</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MathError</span> &#123;</span><br><span class="line">    DivisionByZero,</span><br><span class="line">    NegativeNumber,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">div</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">f64</span>, MathError&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> b != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(a <span class="keyword">as</span> <span class="type">f64</span> / b <span class="keyword">as</span> <span class="type">f64</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(MathError::DivisionByZero)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sqrt</span>(x: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">f64</span>, MathError&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(MathError::NegativeNumber)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(x.<span class="title function_ invoke__">sqrt</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>举例子处理Result，以标准库中对文件的处理为例</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Error opening file: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>对返回的错误进行处理</p>
</li>
<li><p>我们希望对不同的错误原因采取不同的处理方式</p>
</li>
</ul>
<ol>
<li>如果 <code>File::open</code> 因为文件不存在而报错，我们希望创建文件并返回新文件的句柄。</li>
<li>如果 <code>File::open</code> 因为其他的错误而报错，我们希望继续<code>panic！</code>。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file_result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = <span class="keyword">match</span> greeting_file_result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">                ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                    <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                    <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Couldn&#x27;t create the file: &#123;&#125;&quot;</span>, e),</span><br><span class="line">                &#125;,</span><br><span class="line">                other_error =&gt; &#123;</span><br><span class="line">                    <span class="built_in">panic!</span>(<span class="string">&quot;Couldn&#x27;t open the file: &#123;&#125;&quot;</span>, error);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-1-Result-的辅助函数"><a href="#2-1-Result-的辅助函数" class="headerlink" title="2.1 Result&lt;T, E&gt; 的辅助函数"></a>2.1 Result&lt;T, E&gt; 的辅助函数</h5><ol>
<li><p><code>unwrap()</code> 和 <code>unwrap_or()</code>： <code>unwrap()</code> 用于从 <code>Result&lt;T, E&gt;</code> 中获取 <code>T</code> 值，如果<code>Result</code>为空，则 <code>panic</code>。<code>unwrap_or()</code> 用于从 <code>Result&lt;T, E&gt; </code>中获取 T 值，如果 <code>Result</code> 为空，则返回提供的默认值。</p>
</li>
<li><p><code>expect()</code>：<code>expect()</code> 用于从 <code>Result&lt;T, E&gt; </code>中获取 <code>T</code> 值，如果 <code>Result</code> 为空，则 <code>panic</code> 并返回提供的 <code>panic</code> 消息。</p>
</li>
<li><p><code>map</code> : 在<code>Result&lt;T,E&gt;</code> 中对 <code>T </code>值进行处理，返回 <code>Result&lt;U, E&gt;</code>。</p>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">line</span> = <span class="string">&quot;1\n2\n3\n4\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> line.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">match</span> num.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">map</span>(|i| i * <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, num);</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(..) =&gt; &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>map_err</code> : 在 <code>Result&lt;T,E&gt;</code> 中对 <code>E</code> 值进行处理，返回 <code>Result&lt;T, F&gt;</code>。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">x</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">map_err</span>(|e: std::io::Error| <span class="punctuation">-&gt;</span><span class="type">String</span> &#123;<span class="built_in">format!</span>(<span class="string">&quot;Error opening file: &#123;&#125;&quot;</span>, e)&#125;);</span><br><span class="line">    <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(()),</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>在代码运行时，代码是向上层函数传播错误的</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>为了简便，传播错误可以使用简写运算符<code>?</code></p>
</li>
<li><p>对于<code>Result</code> 如果结果是<code>Ok(T)</code>， 则把<code>T</code>赋值给<code>f</code></p>
</li>
<li><p>对于<code>Result</code> 如果结果是<code>Err(E)</code>， 则返回 <code>Err(E)</code></p>
</li>
<li><p>对于<code>Option</code>如果值是<code>Some</code>，<code>Some</code>中的值作为表达式的返回值同时函数继续</p>
</li>
<li><p>如果值是<code>None</code> 则此时<code>None</code>会从函数中提前返回</p>
</li>
<li><p>所以<code>?</code>特别适合用来传播错误</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-Option-和-Result-之间的转换"><a href="#3-Option-和-Result-之间的转换" class="headerlink" title="3. Option 和 Result&lt;T, E&gt; 之间的转换"></a>3. Option<T> 和 Result&lt;T, E&gt; 之间的转换</h4><ol>
<li><code>Option&lt;T&gt;</code> 转 <code>Result&lt;T, E&gt;</code>：</li>
</ol>
<p><code>ok_or</code>：</p>
<ul>
<li><code>Some(t)</code> 转 <code>Ok(t)</code></li>
<li><code>None</code> 转 <code>Err(e)</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first</span>(arr:&amp;[<span class="type">i32</span>] <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;&amp;<span class="type">i32</span>, <span class="type">String</span>&gt;) &#123;</span><br><span class="line">    arr.<span class="title function_ invoke__">get</span>(<span class="number">0</span>).<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;out of bounds&quot;</span>.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>err</code>:</p>
<ul>
<li><code>Err(e)</code> 转 <code>Some(e)</code></li>
<li><code>Ok(e)</code> 转 <code>None</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">err</span>();</span><br><span class="line">    <span class="keyword">if</span> f.<span class="title function_ invoke__">is_some</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;no file found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 输出 no file found</span></span><br></pre></td></tr></table></figure>

<p><code>ok</code>:</p>
<ul>
<li><code>Err(e)</code> 转 <code>None</code></li>
<li><code>Ok(e)</code> 转 <code>Some(e)</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">err</span>();</span><br><span class="line">    <span class="keyword">if</span> f.<span class="title function_ invoke__">is_none</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;no file found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 输出 no file found</span></span><br></pre></td></tr></table></figure>









      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Kunqi Liu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kunqi Liu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
