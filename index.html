<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="0xkunqil">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="0xkunqil">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Kunqi Liu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>0xkunqil</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">0xkunqil</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">kunqi的技术博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/11/twilveth/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kunqi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0xkunqil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/11/twilveth/" class="post-title-link" itemprop="url">Trait 特性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-11-11 11:11:47 / Modified: 19:34:31" itemprop="dateCreated datePublished" datetime="2024-11-11T11:11:47+08:00">2024-11-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li>trait 定义了某个特定类型拥有可能与其他类型共享的功能</li>
<li>trait 类似于其他语言中常被称为 接口（interface）的功能，虽然有一些差别</li>
</ul>
<h4 id="普通实现"><a href="#普通实现" class="headerlink" title="普通实现"></a>普通实现</h4><ul>
<li>使用 <code>trait</code> 关键字来声明一个特征</li>
<li><code>Summary</code> 是特征名</li>
<li>在大括号中定义了该特征的所有方法</li>
<li>只定义特征方法的签名，而不进行实现，此时方法签名结尾是<code>;</code>, 而不是一个<code>&#123;&#125;</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为类型实现特征</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> title: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;文章&#123;&#125;, 作者是&#123;&#125;&quot;</span>, <span class="keyword">self</span>.title, <span class="keyword">self</span>.author);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;发表了微博&#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="特征的定义与实现的位置（孤儿规则）"><a href="#特征的定义与实现的位置（孤儿规则）" class="headerlink" title="特征的定义与实现的位置（孤儿规则）"></a>特征的定义与实现的位置（孤儿规则）</h4><ul>
<li><p>如果你想要为类型<code>A</code>实现特征<code>T</code>，那么<code>A</code>或者<code>T</code>至少需要有一个是在当前作用域定义的</p>
</li>
<li><p>例如，可以为上面的<code>Post</code>类型实现标准库中的<code>Display</code>特征，这是因为<code>Post</code>定义在当前作用区域</p>
</li>
<li><p>可以在当前包中为<code>String</code>类型实现<code>Summary</code>特征，因为<code>Summary</code>定义在当前作用域中</p>
</li>
<li><p>无法在当前作用域中，为<code>String</code>类型实现<code>Display</code>特征，因为他们与当前作用域均无关联</p>
</li>
<li><p>定义一个<code>trait</code>的时候，我们还可以给<code>trait</code>加上一个默认方法：</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Read more ...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>此时如果我们对某个结构体应用一个特性的时候，不做任何的实现</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Post</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对Post来说，就会调用默认的方法，没有实现重载</p>
</li>
<li><p>另一方面，我们定义一个trait的时候，如果存在多个方法定义，可以互相调用，哪怕没有方法实现</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_authors</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Read the author summary &#123;:?&#125;&quot;</span>, summarize_authors)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="带泛形的trait"><a href="#带泛形的trait" class="headerlink" title="带泛形的trait"></a>带泛形的trait</h4><ul>
<li>在具体方法调用的时候，必须加以类型标注，以明确使用的是哪一个具体的实现</li>
<li>可以对同一个目标类型，多次 <code>impl</code> 此 <code>trait</code>，每次提供不同的泛形参数</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Converter</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">convert</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyInt</span>(<span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Converter</span>&lt;<span class="type">String</span>&gt; <span class="keyword">for</span> <span class="title class_">MyInt</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">convert</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Converter</span>&lt;<span class="type">f32</span>&gt; <span class="keyword">for</span> <span class="title class_">MyInt</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">convert</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span> <span class="keyword">as</span> <span class="type">f32</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_int</span> = <span class="title function_ invoke__">MyInt</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">output</span>: <span class="type">String</span> = my_int.<span class="title function_ invoke__">convert</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;output is: &#123;&#125;&quot;</span>, output);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">output</span>: <span class="type">f32</span> = my_int.<span class="title function_ invoke__">convert</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;output is: &#123;&#125;&quot;</span>, output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>以上例子中，使用的时候需要注意，要在定义变量的时候显式注明类型，不然编译器会报错</li>
<li>要注意 <code>方法的泛形</code> 和 <code>trait的泛形</code>的区别</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: <span class="built_in">Default</span>&gt; Convert&lt;T&gt; <span class="keyword">for</span> <span class="title class_">MyInt</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">convert</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">        T::<span class="title function_ invoke__">default</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个时候传递的就是方法的泛形而不是trait的泛形</li>
</ul>
<h4 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h4><ul>
<li><p>关联类型是trait定义中的类型占位符，定义的时候，并不定义它的具体类型是什么，在impl这个trait的时候才为这个关联类型赋予类型定义。</p>
</li>
<li><p>关联类型方式只允许对目标类型实现一次，也就是当你想trait只实现一种类型的时候，可以利用关联类型。</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Converter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">convert</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Converter</span> <span class="keyword">for</span> <span class="title class_">MyInt</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">convert</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="默认泛形类型参数"><a href="#默认泛形类型参数" class="headerlink" title="默认泛形类型参数"></a>默认泛形类型参数</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>&lt;T:std::ops::Add&lt;Output = T&gt;&gt;(a:T, b:T) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add i8: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">2i8</span>, <span class="number">2i8</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add i32: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add f64: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">1.23</span>, <span class="number">1.23</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>实现 Add trait 的时候不指定 Rhs 的具体类型，Rhs的类型将是默认的Self类型，也就是在其上实现Add的类型。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Add</span>&lt;Rhs = <span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, rhs: Rhs) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们以一个坐标轴点的坐标相加作为一个例子，实现一个Add的trait：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Point;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: Point) <span class="punctuation">-&gt;</span> Point &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x + other.x,</span><br><span class="line">            y: <span class="keyword">self</span>.y + other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果两个类型不同，想要相加，又该如何呢：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Millimeters</span>(<span class="type">u32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Meters</span>(<span class="type">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m1</span> = <span class="title function_ invoke__">Millimeters</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m2</span> = <span class="title function_ invoke__">Meters</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="title function_ invoke__">add</span>(m1, m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span>&lt;Meters&gt; <span class="keyword">for</span> <span class="title class_">Millimeters</span> &#123; </span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Millimeters;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: Meters) <span class="punctuation">-&gt;</span> Millimeters &#123;</span><br><span class="line">        <span class="title function_ invoke__">Millimeters</span>(<span class="keyword">self</span>.<span class="number">0</span> + other.<span class="number">0</span> * <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>&lt;T:std::ops::Add&lt;U,Output = T&gt;, U&gt;(a:T, b: U) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="impl-Trait-语法"><a href="#impl-Trait-语法" class="headerlink" title="impl Trait 语法"></a>impl Trait 语法</h4><ul>
<li>你可以使用任何实现了 Summary 特征的类型作为该函数的参数</li>
<li>除了单个约束条件，我们还可以通过 + 语法指定多个约束条件</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;(<span class="keyword">impl</span> <span class="title class_">Summary</span> + Display)) &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Trait-Bound-语法"><a href="#Trait-Bound-语法" class="headerlink" title="Trait Bound 语法"></a>Trait Bound 语法</h4><ul>
<li>impl Trait 适用于短小的例子，它是 trait bound语法的语法糖</li>
<li>更长的 trait bound则适用于更加复杂的场景</li>
<li>除了单个约束条件，我们还可以通过 + 语法指定多个约束条件</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item: &amp;T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display&gt;(item: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>由于此时存在泛形约束，在存在多个不同参数和签名的时候，例如：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display, U:Summary + Display&gt;(item1: &amp;T, item2: &amp;U) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>就会显得非常冗长</li>
<li>我们可以使用 <code>where</code> 关键字这个语法糖改写：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// where 语法简化 trait bound</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T, U&gt;(item1: &amp;T, item2: &amp;U) </span><br><span class="line">    <span class="keyword">where</span> </span><br><span class="line">        T: Summary + Display, </span><br><span class="line">        U:Summary + Display + <span class="built_in">Debug</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用trait-作为泛形的类型"><a href="#使用trait-作为泛形的类型" class="headerlink" title="使用trait 作为泛形的类型"></a>使用trait 作为泛形的类型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> &lt;T:Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp_display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;the larger one is x = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;the larger one is y = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.y)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 对于实现了Display和 PartialOrd的trait的数据而言，就可以使用 cmp_display方法</span></span><br></pre></td></tr></table></figure>

<h4 id="返回一个-trait-类型"><a href="#返回一个-trait-类型" class="headerlink" title="返回一个 trait 类型"></a>返回一个 trait 类型</h4><ul>
<li>类似作为参数的trait，返回值类型也可以返回一个trait类型</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">summarizable</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    Post &#123;</span><br><span class="line">        title: <span class="string">&quot;Summary&quot;</span>.to_string,</span><br><span class="line">        author: <span class="string">&quot;me&quot;</span>.to_string,</span><br><span class="line">        content: <span class="string">&quot;great&quot;</span>.to_string,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果我们要返回多个不同类型，但是都实现了 Summary trait的对象，直接这样写编译器会报错，因为编译器在编译期需要了解对返回对象分配多大的内存，所以如果不指定，就会报错</p>
</li>
<li><p>这个时候可以使用之前用过的Box智能指针</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">summarizable</span>(switch: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Summary&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> switch &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Post &#123;</span><br><span class="line">            title: <span class="string">&quot;Summary&quot;</span>.to_string,</span><br><span class="line">            author: <span class="string">&quot;me&quot;</span>.to_string,</span><br><span class="line">            content: <span class="string">&quot;great&quot;</span>.to_string,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Weibo &#123;</span><br><span class="line">            username: <span class="string">&quot;me&quot;</span>.to_string,</span><br><span class="line">            content: <span class="string">&quot;great&quot;</span>.to_string,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常用派生特征语法"><a href="#常用派生特征语法" class="headerlink" title="常用派生特征语法"></a>常用派生特征语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#[derivce(Debug)] // 格式化输出 &#123;:?&#125;</span><br><span class="line"></span><br><span class="line">#[derive(Default)] // </span><br><span class="line"></span><br><span class="line">#[derive(Debug, Default)] // 多个派生写法</span><br><span class="line"></span><br><span class="line">#[derive(Copy)] // 避免所有权移动</span><br></pre></td></tr></table></figure>

<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><ul>
<li><p>错误代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;fmt::Display, ops::Add, process::Output&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要改Item的定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要改Apple结构的定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Apple</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Item</span> <span class="keyword">for</span> <span class="title class_">Apple</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; </span><br><span class="line">        <span class="keyword">self</span>.name.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    author: <span class="type">String</span>,</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Item</span> <span class="keyword">for</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;@&#123;&#125;:&#123;&#125;&quot;</span>, <span class="keyword">self</span>.author, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    items: <span class="type">Vec</span>&lt;Item&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">iterator</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> <span class="keyword">self</span>.items &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">apple</span> = Apple &#123;</span><br><span class="line">        name: <span class="string">&quot;Apple&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = Weibo &#123;</span><br><span class="line">        author: <span class="string">&quot;Weibo&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        content: <span class="string">&quot;Hello, World!&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">container</span> = Container &#123;</span><br><span class="line">        items: <span class="built_in">vec!</span>[apple, w],</span><br><span class="line">    &#125;;</span><br><span class="line">    container.<span class="title function_ invoke__">iterator</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>改法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;fmt::Display, ops::Add, process::Output&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要改Item的定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要改Apple结构的定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Apple</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Item</span> <span class="keyword">for</span> <span class="title class_">Apple</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">String</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; </span><br><span class="line">        <span class="keyword">self</span>.name.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    author: <span class="type">String</span>,</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Item</span> <span class="keyword">for</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">String</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;@&#123;&#125;:&#123;&#125;&quot;</span>, <span class="keyword">self</span>.author, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    items: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Item&lt;Output = <span class="type">String</span>&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">iterator</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> &amp;<span class="keyword">self</span>.items &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">apple</span> = Apple &#123;</span><br><span class="line">        name: <span class="string">&quot;Apple&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = Weibo &#123;</span><br><span class="line">        author: <span class="string">&quot;Weibo&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        content: <span class="string">&quot;Hello, World!&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">container</span> = Container &#123;</span><br><span class="line">        items: <span class="built_in">vec!</span>[<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(apple), <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(w)],</span><br><span class="line">    &#125;;</span><br><span class="line">    container.<span class="title function_ invoke__">iterator</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/06/eleventh_chapter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kunqi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0xkunqil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/06/eleventh_chapter/" class="post-title-link" itemprop="url">Rust基础：生命周期</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-06 18:22:06" itemprop="dateCreated datePublished" datetime="2024-11-06T18:22:06+08:00">2024-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-07 23:37:37" itemprop="dateModified" datetime="2024-11-07T23:37:37+08:00">2024-11-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li><p>在Rust中，生命周期是用来解决借用的限制问题的。生命周期是指在程序运行时，某个值的有效范围。生命周期的作用是保证借用的值在借用结束之前有效。</p>
</li>
<li><p>有些值具有静态生命周期，它们会在整个程序运行期间一直有效。比如：</p>
</li>
</ul>
<ol>
<li>全局变量</li>
<li>静态变量</li>
<li>字符串字面量</li>
<li>函数指针</li>
<li>&amp;‘static T类型的引用</li>
<li>而其他的类型，比如局部变量，函数参数，函数返回值等，都是具有动态生命周期的，它们的生命周期是在函数调用时确定的。</li>
</ol>
<h3 id="生命周期参数"><a href="#生命周期参数" class="headerlink" title="生命周期参数"></a>生命周期参数</h3><ul>
<li>在Rust中，生命周期参数是用来描述引用的生命周期的，它的语法是’a，其中a是生命周期参数的名称，可以是任意的合法标识符。生命周期参数位于引用符号&amp;和引用的类型之间，比如：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="type">i32</span> <span class="comment">// 引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span> <span class="comment">// 标注生命周期参数的不可变引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">i32</span> <span class="comment">// 标注生命周期参数的可变引用</span></span><br></pre></td></tr></table></figure>
<ul>
<li>标注的生命周期参数只是用于编译器的借用检查。</li>
</ul>
<h3 id="生命周期消除（Lifetime-Elision）"><a href="#生命周期消除（Lifetime-Elision）" class="headerlink" title="生命周期消除（Lifetime Elision）"></a>生命周期消除（Lifetime Elision）</h3><ul>
<li>某些情况下，生命周期可以由Rust编译器自动推理，无需手动重复添加</li>
</ul>
<ol>
<li>每个引用参数都有自己的生命周期参数</li>
<li>如果只有一个输入引用参数，那么它的生命周期会被赋予所有输出引用。</li>
<li>如果有多个输入生命周期参数，但其中一个是<code>&amp;self</code>或<code>&amp;mut self</code>，那么 <code>self</code> 的生命周期会被赋予所有输出引用。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_world</span>(s: &amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    &amp;s[..<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">log</span>(a: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="type">str</span>, &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    (a, a)</span><br><span class="line">&#125; <span class="comment">// 以上情况，所有输出引用的生命周期都是输入引用的生命周期</span></span><br></pre></td></tr></table></figure>

<p>以一个例子完整了解一下生命周期问题：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test_lifetime_multiple</span>() &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">insert_value</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(my_vec: &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>&gt;, value: &amp;<span class="symbol">&#x27;b</span> <span class="type">i32</span>)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="symbol">&#x27;b</span>:<span class="symbol">&#x27;a</span></span><br><span class="line">    &#123;</span><br><span class="line">        my_vec.<span class="title function_ invoke__">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_vec</span>: <span class="type">Vec</span>&lt;&amp;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">val1</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">val2</span> = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">insert_value</span>(&amp;<span class="keyword">mut</span> my_vec, &amp;val1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;my_vec is &#123;:?&#125;&quot;</span>, my_vec);</span><br><span class="line">    <span class="title function_ invoke__">insert_value</span>(&amp;<span class="keyword">mut</span> my_vec, &amp;val2); <span class="comment">// 报借用冲突错误</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;my_vec is &#123;:?&#125;&quot;</span>, my_vec);</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;my_vec:?&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>对于上述代码，第二次调用insert_value时报错：cannot borrow <code>my_vec</code> as mutable more than once at a time， 这代表我们在同一时间存在多个统一变量的可变引用，造成所有权冲突。</p>
</li>
<li><p>这是因为，<code>my_vec</code>和<code>value</code>实际上生命周期一致，由于val1和val2的生命周期为<code>‘static</code>，所以<code>my_vec</code>的可变引用生命周期产生了外扩</p>
</li>
<li><p>这个时候，解决方式就是将<code>my_vec</code>的生命周期标注删除</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test_lifetime_multiple</span>() &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">insert_value</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(my_vec: &amp;<span class="keyword">mut</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>&gt;, value: &amp;<span class="symbol">&#x27;b</span> <span class="type">i32</span>)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="symbol">&#x27;b</span>:<span class="symbol">&#x27;a</span></span><br><span class="line">    &#123;</span><br><span class="line">        my_vec.<span class="title function_ invoke__">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_vec</span>: <span class="type">Vec</span>&lt;&amp;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">val1</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">val2</span> = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">insert_value</span>(&amp;<span class="keyword">mut</span> my_vec, &amp;val1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;my_vec is &#123;:?&#125;&quot;</span>, my_vec);</span><br><span class="line">    <span class="title function_ invoke__">insert_value</span>(&amp;<span class="keyword">mut</span> my_vec, &amp;val2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;my_vec is &#123;:?&#125;&quot;</span>, my_vec);</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;my_vec:?&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>此时，编译期将不再报冲突问题。</p>
</li>
<li><p>还有一种解决方式，就是利用RefCell的内部可变性解决：</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test_lifetime_multiple</span>() &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">insert_value</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(my_vec: &amp;<span class="symbol">&#x27;a</span> RefCell&lt;<span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>&gt;&gt;, value: &amp;<span class="symbol">&#x27;b</span> <span class="type">i32</span>)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="symbol">&#x27;b</span>:<span class="symbol">&#x27;a</span></span><br><span class="line">    &#123;</span><br><span class="line">        my_vec.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_vec</span> =RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">val1</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">val2</span> = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">insert_value</span>(&amp;my_vec, &amp;val1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;my_vec is &#123;:?&#125;&quot;</span>, my_vec.<span class="title function_ invoke__">borrow</span>());</span><br><span class="line">    <span class="title function_ invoke__">insert_value</span>(&amp;my_vec, &amp;val2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;my_vec is &#123;:?&#125;&quot;</span>, my_vec.<span class="title function_ invoke__">borrow</span>());</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;my_vec:?&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>由于其内部可变性，我们入参可以改为不可变引用，符合所有权借用的规则</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/03/tenth_chapter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kunqi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0xkunqil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/03/tenth_chapter/" class="post-title-link" itemprop="url">Rust基础：智能指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-03 23:09:01" itemprop="dateCreated datePublished" datetime="2024-11-03T23:09:01+08:00">2024-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-06 00:27:58" itemprop="dateModified" datetime="2024-11-06T00:27:58+08:00">2024-11-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><ul>
<li><p>智能指针是一类数据结构，它不仅包含一个指针，还附带一些额外的元数据和功能，与普通指针不同，智能指针还在Rust中实现了<code>Deref</code> 和 <code>Drop</code> 两个 trait，这使得它们可以像指针一样解引用，并且在离开作用域时自动清理资源。</p>
</li>
<li><p>存在智能指针的目的有以下几点：</p>
</li>
</ul>
<ol>
<li>资源管理：自动管理资源的分配与释放，避免内存泄漏。</li>
<li>所有权与借用：Rust所有权系统通过智能指针来确保内存安全，避免数据竞争和悬垂指针。</li>
<li>复杂数据结构：通过智能指针可以构建复杂的数据结构，如递归结构、共享数据等。</li>
</ol>
<ul>
<li>智能指针的特性</li>
</ul>
<ol>
<li>Deref trait： 实现了 Deref trait 的类型可以像常规引用一样使用<code>*</code>解引用</li>
<li>Drop trait：实现了 Drop trait 的类型在离开作用域时，会自动调用drop方法，用于释放资源</li>
</ol>
<h4 id="Box-指针"><a href="#Box-指针" class="headerlink" title="Box 指针"></a>Box<T> 指针</h4><ul>
<li><code>Box&lt;T&gt;</code> 将类型<code>T</code>的值分配在堆上而不是栈上。</li>
<li>当 <code>Box</code> 被销毁时，堆上的数据也会被销毁。</li>
</ul>
<ol>
<li>Box的底层原理：<code>Box&lt;T&gt;</code>实际上是一个智能指针，内部包含一个指向堆上分配内存的裸指针。</li>
</ol>
<ul>
<li>当其被销毁时，Drop trait 会被调用，释放堆上的内存。</li>
</ul>
<ol start="2">
<li>内存分配：Rust使用系统的全局分配器（如 malloc 和 free）来管理内存</li>
</ol>
<ul>
<li>Box::new 分配内存，Drop 释放内存</li>
</ul>
<ol start="3">
<li>安全性：Rust的所有权系统确保 <code>Box&lt;T&gt;</code> 的内存安全，所有权转移时，堆内存的生命周期也会随之变化。</li>
<li>Box 处理较大数据结构或数据结构大小在编译时不确定时尤为方便。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>: <span class="type">Box</span>&lt;<span class="type">str</span>&gt; = <span class="string">&quot;Hello, world&quot;</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s =  &#123;:?&#125;&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: <span class="type">Box</span>&lt;[<span class="type">i32</span>]&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="title function_ invoke__">into_boxed_slice</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;arr = &#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到 Box 允许处理动态大小类型，如 <code>str</code> 和 <code>[T]</code>。</li>
</ul>
<ol start="5">
<li>在Rust中，如果直接使用递归数据结构是不行的，因为编译的时候需要一个确定的内容</li>
</ol>
<ul>
<li>但是通过 Box 指针，可以实现递归</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list</span> = List::<span class="title function_ invoke__">Cons</span>(<span class="number">1</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(List::<span class="title function_ invoke__">Cons</span>(<span class="number">2</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(List::Nil))));</span><br><span class="line">&#125; <span class="comment">// 实现了一个链表结构</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>Box 的类型擦除</li>
</ol>
<ul>
<li><code>Box&lt;dyn Trait&gt;</code> 用于类型擦除，可以允许在运行时决定类型</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Animals</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">to_speak</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cat</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animals</span> <span class="keyword">for</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">to_speak</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;wow!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animals</span> <span class="keyword">for</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">to_speak</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;meow!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">animal</span>: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Animals&gt;&gt; = <span class="built_in">vec!</span>[<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Dog), <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Cat)];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">animal</span> <span class="keyword">in</span> animal.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        animal.<span class="title function_ invoke__">to_speak</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：wow! meow! </p>
</blockquote>
<ul>
<li>这里的<code>dyn</code>关键字声明了一个动态类型，所以向量中可以放置不同类型的结构体</li>
<li><code>dyn</code>用于实现一个动态分发的trait对象，允许在运行时决定具体类型</li>
</ul>
<ol start="7">
<li>内存管理和性能优化</li>
</ol>
<ul>
<li>通过使用Box，可以控制内存的分配和释放，从而优化性能和内存使用，例如，将大型数据结构放在堆上而不是栈上，减少栈的使用量，避免栈溢出。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">large_array</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>([<span class="number">0u8</span>;<span class="number">1_000_000</span>]);  </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Large array allocated on the heap: &quot;</span> + large_array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>分配效率比较</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::time::Instant;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">now</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_array</span>  = <span class="built_in">vec!</span>[<span class="number">100_000_000</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">end</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;After the big array creation, the time is &#123;:?&#125;&quot;</span>, end - now);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">now_2</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_box_array</span>:<span class="type">Box</span>&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt; = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[<span class="number">100_000_000</span>]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">end_2</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;After create big boxed array creation, the time is &#123;:?&#125;&quot;</span>, end_2 - now_2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：After the big array creation, the time is 18.791µs<br>After create big boxed array creation, the time is 541ns</p>
</blockquote>
<ul>
<li><p>可以看到分配在堆上的时间远小于分配在栈上的时间</p>
</li>
<li><p>Box 的优缺点：</p>
</li>
</ul>
<ol>
<li>优点：提供内存分配；支持复杂数据结构；内存安全；动态分配对象，实现类型擦除</li>
<li>缺点：不适合频繁分配和释放的场景</li>
</ol>
<h4 id="Drop、Deref-和-DerefMut"><a href="#Drop、Deref-和-DerefMut" class="headerlink" title="Drop、Deref 和 DerefMut"></a>Drop、Deref 和 DerefMut</h4><ul>
<li>Drop trait: 定义了当一个值离开作用域时应该执行的操作，通常用于释放资源（内存，文件句柄，网络连接）。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Resources</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">Resources</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;resouces &#123;:?&#125; has been dropped&quot;</span>, <span class="keyword">self</span>.name);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res1</span> = Resources &#123;name: <span class="string">&quot;resouces1&quot;</span>.<span class="title function_ invoke__">to_string</span>()&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res2</span> = Resources &#123;name: <span class="string">&quot;resouces2&quot;</span>.<span class="title function_ invoke__">to_string</span>()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>离开作用域时，drop被调用</p>
<blockquote>
<p>输出：resouces “resouces2” has been dropped<br>resouces “resouces1” has been dropped</p>
</blockquote>
</li>
<li><p>trait的实现如下</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Drop</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Deref trait：定义了如何将一个类型转换为引用，用于重载解引用运算符<code>*</code>，它允许你定义自定义指针类型的解引用行为。该trait定义了一个deref方法，该方法返回指向目标类型的引用。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Deref</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span>: ?sized; <span class="comment">// ?sized 表示可以持有动态大小类型</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref; <span class="comment">// Deref trait在标准库中的ops库里</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt; (T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(value: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;deref is called.&quot;</span>);</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = MyBox::<span class="title function_ invoke__">new</span>(x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y is: &#123;&#125;&quot;</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：x is: 5<br>deref is called.<br>y is: 5  </p>
</blockquote>
<ul>
<li><p>我们可以看到，解引用被调用</p>
</li>
<li><p>DerefMut trait: 与Deref类似，DerefMut用于重载可变解引用运算符，允许对自定义类型进行可变解引用。</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">DerefMut</span>: Deref &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> <span class="keyword">Self</span>::Target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现可变解引用</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; DerefMut <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> T &#123;</span><br><span class="line">        <span class="title function_ invoke__">println</span>(<span class="string">&quot;DerefMut has been called&quot;</span>);</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Rc"><a href="#Rc" class="headerlink" title="Rc"></a>Rc<T></h4><ul>
<li><p>Rc 是 Reference Counted 的缩写，引用计数指针，是一个允许多所有者的共享所有权模型</p>
</li>
<li><p>它可以统计有多少个有效引用，当有效引用为0的时候，数据就可以被清理掉</p>
</li>
<li><p>举例说明<br><img src="/image.png" alt="alt text"></p>
</li>
</ul>
<ol>
<li>使用生命周期引用：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, &amp;<span class="symbol">&#x27;a</span> List&lt;<span class="symbol">&#x27;a</span>&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">study</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>:List = <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, &amp;List::<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>,&amp;Nil));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>:List = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, &amp;a);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span>:List = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, &amp;a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">study</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：Cons(5, Cons(10, Nil))<br>Cons(3, Cons(5, Cons(10, Nil)))<br>Cons(4, Cons(5, Cons(10, Nil)))  </p>
</blockquote>
<ol start="2">
<li>使用Rc<T>实现：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">study</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a)));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a)));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">study</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：Cons(5, Cons(10, Nil))<br>Cons(3, Cons(5, Cons(10, Nil)))<br>Cons(4, Cons(5, Cons(10, Nil)))</p>
</blockquote>
</li>
</ol>
<ul>
<li><p>我们也可以打印出引用计数看看：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">study</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a)));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a)));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：1<br>2<br>3  </p>
</blockquote>
</li>
<li><p>说明引用次数依次增加，当study函数作用域结束，所有引用将被释放。</p>
</li>
</ul>
<h4 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell"></a>RefCell<T></h4><ul>
<li>RefCell<T> 是 Rust 标准库中的一个智能指针类型，它提供了内部可变性，允许在不可变引用的情况下去修改数据。这种特性使得你可以在编译时保证安全的情况下动态地借用和修改数据。</li>
</ul>
<ol>
<li><p>内部可变性：<code>RefCell&lt;T&gt;</code> 允许你在其内部的 <code>T</code> 中进行修改，即使<code>RefCell&lt;T&gt;</code>本身是不可变的，这是通过借用检查实现的。</p>
</li>
<li><p>运行时借用检查：<code>RefCell</code> 使用运行时借用检查，确保在运行时遵循Rust的借用规则，即只允许同时存在一个可变借用或者多个不可变借用，编译时不会产生借用检查，如果出现借用冲突，会panic！。</p>
</li>
<li><p>borrow 和 borrow_mut 方法：提供了两个方法，borrow()获取多个不可变借用（Ref<T>）, borrow_mut() 获取一个可变借用（RefMut<T>）。</p>
</li>
<li><p>与 Cell 用于可 Copy 的值不同，RefCell 用于引用；RefCell 只是将借用规则从编译期推迟到程序运行期，并不能帮你绕过这个规则；RefCell 适用于编译期误报或者一个引用被在多处代码使用、修改以至于难于管理借用关系时。</p>
</li>
</ol>
<ul>
<li>使用场景：受限于所有权系统，需要共享且修改数据（树，图），主要用于单线程环境</li>
</ul>
<h4 id="Rc-RefCell-组合使用"><a href="#Rc-RefCell-组合使用" class="headerlink" title="Rc + RefCell 组合使用"></a>Rc + RefCell 组合使用</h4><ul>
<li>在 Rust 中，一个常见的组合就是 Rc 和 RefCell 在一起使用，前者可以实现一个数据拥有多个所有者，后者可以实现数据的可变性：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="string">&quot;我很善变，还拥有多个主人&quot;</span>.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="comment">// let mut s2 = s.borrow_mut();</span></span><br><span class="line">    s2.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, oh yeah!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;\n&#123;:?&#125;\n&#123;:?&#125;&quot;</span>, s, s1, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：RefCell { value: “我很善变，还拥有多个主人, oh yeah!” }<br>RefCell { value: “我很善变，还拥有多个主人, oh yeah!” }<br>RefCell { value: “我很善变，还拥有多个主人, oh yeah!” }  </p>
</blockquote>
<ul>
<li><p>上面代码中，我们使用 RefCell<String> 包裹一个字符串，同时通过 Rc 创建了它的三个所有者：s、s1和s2，并且通过其中一个所有者 s2 对字符串内容进行了修改。</p>
</li>
<li><p>由于 Rc 的所有者们共享同一个底层的数据，因此当一个所有者修改了数据时，会导致全部所有者持有的数据都发生了变化。</p>
</li>
</ul>
<h4 id="引用循环和内存泄漏"><a href="#引用循环和内存泄漏" class="headerlink" title="引用循环和内存泄漏"></a>引用循环和内存泄漏</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::&#123;Ref, RefCell&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    next:<span class="type">Option</span>&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(Node &#123; value: <span class="number">1</span>, next: <span class="literal">None</span>&#125;));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(Node &#123; value: <span class="number">2</span>, next: <span class="literal">None</span>&#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建引用循环</span></span><br><span class="line"></span><br><span class="line">    first.<span class="title function_ invoke__">borrow_mut</span>().next = <span class="title function_ invoke__">Some</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;second));</span><br><span class="line">    second.<span class="title function_ invoke__">borrow_mut</span>().next = <span class="title function_ invoke__">Some</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;first));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;first strong count :&#123;:?&#125; and first weak count: &#123;:?&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;first), Rc::<span class="title function_ invoke__">weak_count</span>(&amp;first));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;second strong count :&#123;:?&#125; and second weak count: &#123;:?&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;second), Rc::<span class="title function_ invoke__">weak_count</span>(&amp;second));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, first);  <span class="comment">// 发生 stackoverflow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：…..省略重复 { value: 1, next: Some(RefCell { value: Node { value: 2, next: Some(RefCell { value: Node { value: 1, next: Some(RefCell { value: Node { value: 2, next: Some(RefCell { value: Node { value: 1, next: Some(RefCell { value: Node { value: 2, next: Some(RefCell { value: Node { value: 1, next: Some(RefCell { value: Node { value: 2, next: Some(RefCell { value: Node { value: 1, next: Some(RefCell { value: Node { value: 2, next: Some(RefCell { value: Node { value: 1, next: Some(RefCell { value: Node { value: 2, next: Some(RefCell { value: Node { value: 1, next: Some(RefCell { value: Node { value: 2, next: Some(RefCell { value: Node { value: 1, next: Some(RefCell { value: Node { value: 2, next: Some(RefCell { value: Node { value: 1, next: Some(RefCell { value: Node { value: 2<br>thread ‘main’ has overflowed its stack<br>fatal runtime error: stack overflow  </p>
</blockquote>
<ul>
<li>栈溢出了</li>
</ul>
<h4 id="Weak"><a href="#Weak" class="headerlink" title="Weak"></a>Weak<T></h4><ul>
<li>非所有权引用，不影响<code>Rc&lt;T&gt;</code>的引用计数</li>
<li>避免了引用循环问题，不会引发内存泄漏</li>
<li>必须升级，由于它是一个非所有权引用，在使用数据前，必须通过<code>upgrade()</code>来升级成为<code>Rc&lt;T&gt;</code>，如果数据已经被释放，则<code>upgrade()</code>返回<code>None</code>。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::&#123;Rc, Weak&#125;;</span><br><span class="line"><span class="keyword">use</span> std::cell::&#123;Ref, RefCell&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    next:<span class="type">Option</span>&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,</span><br><span class="line">    prev: <span class="type">Option</span>&lt;Weak&lt;RefCell&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(Node &#123; value: <span class="number">1</span>, next: <span class="literal">None</span>, prev: <span class="literal">None</span> &#125;));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(Node &#123; value: <span class="number">2</span>, next: <span class="literal">None</span>, prev: <span class="literal">None</span> &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建引用循环</span></span><br><span class="line"></span><br><span class="line">    first.<span class="title function_ invoke__">borrow_mut</span>().next = <span class="title function_ invoke__">Some</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;second));</span><br><span class="line">    second.<span class="title function_ invoke__">borrow_mut</span>().prev = <span class="title function_ invoke__">Some</span>(Rc::<span class="title function_ invoke__">downgrade</span>(&amp;first)); <span class="comment">// 弱引用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;first strong count :&#123;:?&#125; and first weak count: &#123;:?&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;first), Rc::<span class="title function_ invoke__">weak_count</span>(&amp;first));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;second strong count :&#123;:?&#125; and second weak count: &#123;:?&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;second), Rc::<span class="title function_ invoke__">weak_count</span>(&amp;second));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, first);  <span class="comment">// 发生 stackoverflow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出： first strong count :1 and first weak count: 1<br>second strong count :2 and second weak count: 0<br>RefCell { value: Node { value: 1, next: Some(RefCell { value: Node { value: 2, next: None, prev: Some((Weak)) } }), prev: None } }  </p>
</blockquote>
<ul>
<li>解决引用循环的问题</li>
</ul>
<h4 id="强引用和弱引用的主要区别"><a href="#强引用和弱引用的主要区别" class="headerlink" title="强引用和弱引用的主要区别"></a>强引用和弱引用的主要区别</h4><ol>
<li><p>所有权：强引用 <code>Rc&lt;T&gt;</code> 持有数据的所有权，保证数据在作用域内不被释放；弱引用<code>Weak&lt;T&gt;</code>不持有数据的所有权，不影响数据的生命周期。</p>
</li>
<li><p>引用计数：强引用增加引用计数，数据被多个所有者共享；弱引用不增加引用计数，不干扰<code>Rc&lt;T&gt;</code>的生命周期管理。</p>
</li>
<li><p>内存管理：强引用只有当所有强引用都被丢弃时，数据才会被释放；弱引用只能通过升级<code>upgrade()</code>来访问数据，如果数据已经被释放，则升级会失败。</p>
</li>
<li><p>适用场景：强引用当你希望共享数据并确保数据至少有一个强引用存在时不被释放；弱引用当你需要避免引用循环，或只需要偶尔访问数据，不想持有所有权时。</p>
</li>
</ol>
<h4 id="社交网络系统例子"><a href="#社交网络系统例子" class="headerlink" title="社交网络系统例子"></a>社交网络系统例子</h4><p><img src="/image-1.png" alt="alt text"></p>
<ul>
<li>如何实现：</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/03/nineth_chapter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kunqi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0xkunqil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/03/nineth_chapter/" class="post-title-link" itemprop="url">Rust基础：模块化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-11-03 00:29:41 / Modified: 18:32:19" itemprop="dateCreated datePublished" datetime="2024-11-03T00:29:41+08:00">2024-11-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-模块化"><a href="#1-模块化" class="headerlink" title="1. 模块化"></a>1. 模块化</h3><ul>
<li>当工程规模变大时，把代码写到一个甚至几个文件中，都是不太聪明的做法，可能存在以下问题：</li>
</ul>
<ol>
<li>单个文件过大，导致打开、翻页速度大幅变慢</li>
<li>查询和定位效率大幅降低，类比下，你会把所有知识内容放在一个几十万字的文档中吗？</li>
<li>只有一个代码层次：函数，难以维护和协作，想象一下你的操作系统只有一个根目录，剩下的都是单层子目录会如何：disaster!容易滋生 Bug</li>
<li>同时，将大的代码文件拆分成包和模块，还允许我们实现代码抽象和复用：将你的代码封装好后提供给用户，那么用户只需要调用公共接口即可，无需知道内部该如何实现。</li>
</ol>
<ul>
<li>因此，跟其它语言一样，Rust 也提供了相应概念用于代码的组织管理：</li>
</ul>
<ol>
<li>项目(Packages)：一个 Cargo 提供的 feature，可以用来构建、测试和分享包</li>
<li>包(Crate)：一个由多个模块组成的树形结构，可以作为三方库进行分发，也可以生成可执行文件进行运行</li>
<li>模块(Module)：可以一个文件多个模块，也可以一个文件一个模块，模块可以被认为是真实项目中的代码组织单元</li>
</ol>
<ul>
<li>其实项目 Package 和包 Crate 很容易被搞混，甚至在很多书中，这两者都是不分的，但是由于官方对此做了明确的区分，因此我们会在本章节中试图（挣扎着）理清这个概念。</li>
</ul>
<h4 id="1-1-包-Crate"><a href="#1-1-包-Crate" class="headerlink" title="1.1 包 Crate"></a>1.1 包 Crate</h4><ul>
<li><p>对于 Rust 而言，包是一个独立的可编译单元，它编译后会生成一个可执行文件或者一个库。</p>
</li>
<li><p>一个包会将相关联的功能打包在一起，使得该功能可以很方便的在多个项目中分享。例如标准库中没有提供但是在三方库中提供的 rand 包，它提供了随机数生成的功能，我们只需要将该包通过 use rand; 引入到当前项目的作用域中，就可以在项目中使用 rand 的功能：rand::XXX。</p>
</li>
<li><p>同一个包中不能有同名的类型，但是在不同包中就可以。例如，虽然 rand 包中，有一个 Rng 特征，可是我们依然可以在自己的项目中定义一个 Rng，前者通过 rand::Rng 访问，后者通过 Rng 访问，对于编译器而言，这两者的边界非常清晰，不会存在引用歧义。</p>
</li>
</ul>
<h4 id="1-2-项目-Package"><a href="#1-2-项目-Package" class="headerlink" title="1.2 项目 Package"></a>1.2 项目 Package</h4><ul>
<li><p>鉴于 Rust 团队标新立异的起名传统，以及包的名称被 crate 占用，库的名称被 library 占用，经过斟酌， 我们决定将 Package 翻译成项目，你也可以理解为工程、软件包。</p>
</li>
<li><p>由于 Package 就是一个项目，因此它包含有独立的 Cargo.toml 文件，以及因为功能性被组织在一起的一个或多个包。一个 Package 只能包含一个库(library)类型的包，但是可以包含多个二进制可执行类型的包。</p>
</li>
</ul>
<ol>
<li>二进制package：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new my-project</span><br><span class="line">     Created <span class="title function_ invoke__">binary</span> (application) `my-project` package</span><br><span class="line">$ ls my-project</span><br><span class="line">Cargo.toml</span><br><span class="line">src</span><br><span class="line">$ ls my-project/src</span><br><span class="line">main.rs</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>这里，<code>Cargo</code> 为我们创建了一个名称是 <code>my-project</code> 的 Package，同时在其中创建了 <code>Cargo.toml</code> 文件，可以看一下该文件，里面并没有提到 src&#x2F;main.rs 作为程序的入口，原因是 Cargo 有一个惯例：<code>src/main.rs</code> 是二进制包的根文件，该二进制包的包名跟所属 Package 相同，在这里都是 <code>my-project</code>，所有的代码执行都从该文件中的 <code>fn main()</code> 函数开始。</li>
</ul>
<blockquote>
<p>使用 cargo run 可以运行该项目，输出：Hello, world!。</p>
</blockquote>
<ol start="2">
<li>库package：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new my-lib --lib</span><br><span class="line">     Created library `my-lib` package</span><br><span class="line">$ ls my-lib</span><br><span class="line">Cargo.toml</span><br><span class="line">src</span><br><span class="line">$ ls my-lib/src</span><br><span class="line">lib.rs</span><br></pre></td></tr></table></figure>

<ul>
<li><p>不能直接运行：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">error: a bin target must be available <span class="keyword">for</span> `cargo run`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>典型工程结构</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">├── Cargo.toml</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── src</span><br><span class="line">│   ├── main.rs</span><br><span class="line">│   ├── lib.rs</span><br><span class="line">│   └── bin</span><br><span class="line">│       └── main1.rs</span><br><span class="line">│       └── main2.rs</span><br><span class="line">├── tests</span><br><span class="line">│   └── some_integration_tests.rs</span><br><span class="line">├── benches</span><br><span class="line">│   └── simple_bench.rs</span><br><span class="line">└── examples</span><br><span class="line">    └── simple_example.rs</span><br></pre></td></tr></table></figure>

<ul>
<li>唯一库包：src&#x2F;lib.rs</li>
<li>默认二进制包：src&#x2F;main.rs，编译后生成的可执行文件与 Package 同名</li>
<li>其余二进制包：src&#x2F;bin&#x2F;main1.rs 和 src&#x2F;bin&#x2F;main2.rs，它们会分别生成一个文件同名的二- 进制可执行文件</li>
<li>集成测试文件：tests 目录下</li>
<li>基准性能测试 benchmark 文件：benches 目录下</li>
<li>项目示例：examples 目录下</li>
</ul>
<h4 id="1-3-模块-Modules"><a href="#1-3-模块-Modules" class="headerlink" title="1.3 模块 Modules"></a>1.3 模块 Modules</h4><ul>
<li><p>pub</p>
</li>
<li><p>mod</p>
</li>
<li><p>use</p>
</li>
<li><p>as</p>
</li>
<li><p>创建一个嵌套模块：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 餐厅前厅，用于吃饭</span></span><br><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_payment</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>以上的代码创建了三个模块，有几点需要注意的：</p>
</li>
</ul>
<ol>
<li>使用 mod 关键字来创建新模块，后面紧跟着模块名称</li>
<li>模块可以嵌套，这里嵌套的原因是招待客人和服务都发生在前厅，因此我们的代码模拟了真实场景</li>
<li>模块中可以定义各种 Rust 类型，例如函数、结构体、枚举、特征等</li>
<li>所有模块均定义在同一个文件中</li>
<li>类似上述代码中所做的，使用模块，我们就能将功能相关的代码组织到一起，然后通过一个模块名称来说明这些代码为何被组织在一起。这样其它程序员在使用你的模块时，就可以更快地理解和上手。</li>
</ol>
<h4 id="1-4-路径"><a href="#1-4-路径" class="headerlink" title="1.4 路径"></a>1.4 路径</h4><ul>
<li><p>Rust当中路径访问使用<code>::</code>来访问</p>
</li>
<li><p>Rust当中所有的定义默认是私有的，只有在模块内可以被访问，如果需要在外部使用，可以加上<code>pub</code>关键字</p>
</li>
<li><p>绝对路径访问：<code>crate::front_of_house::hosting::add_to_waitlist()</code></p>
</li>
<li><p>相对路径访问：<code>super::add_to_waitlist()</code></p>
</li>
<li><p><code>super</code> 关键字可以跳转到上一级模块</p>
</li>
<li><p>相对路径可以用<code>self</code>来表示当前模块，<code>super</code>来表示上一级模块</p>
</li>
</ul>
<h4 id="1-5-使用-use-关键字来引入模块"><a href="#1-5-使用-use-关键字来引入模块" class="headerlink" title="1.5 使用 use 关键字来引入模块"></a>1.5 使用 use 关键字来引入模块</h4><ul>
<li>如果模块存在嵌套，访问子模块内方法时需要逐级使用<code>::</code>，且方法需要定义为public</li>
<li>由于每次访问都需要逐级访问，我们可以用<code>use</code>来简化路径:类似alias</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::serving;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果a模块有一个方法，子模块b也有一个方法，两个方法是同名方法，以log()为例，可以用<code>as</code>来重新定义方法名</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> a::&#123;b::log <span class="keyword">as</span> log2, log&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>同时 <code>as</code>也可以作为类型转换语句</li>
</ul>
<h4 id="1-6-模块可见性"><a href="#1-6-模块可见性" class="headerlink" title="1.6 模块可见性"></a>1.6 模块可见性</h4><ul>
<li>private（default）</li>
<li>pub(crate)</li>
<li>pub(in path)</li>
<li>pub use</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">in</span> crate::front_of_house) <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>只有在 crate::front_of_house 路径下可以访问 seat_at_table() 方法</li>
<li>pub use 关键字可以将模块中的项公开到外面</li>
</ul>
<h4 id="1-7-workspace"><a href="#1-7-workspace" class="headerlink" title="1.7 workspace"></a>1.7 workspace</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Cargo.toml</span><br><span class="line">[workspace]</span><br><span class="line">members = [</span><br><span class="line">    &quot;my-project&quot;,</span><br><span class="line">    &quot;my-lib&quot;,</span><br><span class="line">    &quot;my-lib/my-sublib&quot;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li>Cargo.toml 里面的 members 是一个数组，包含了需要构建的多个 Package。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/02/eighth_chapter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kunqi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0xkunqil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/02/eighth_chapter/" class="post-title-link" itemprop="url">Rust基础：返回值与错误处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-02 22:21:48" itemprop="dateCreated datePublished" datetime="2024-11-02T22:21:48+08:00">2024-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-03 00:26:13" itemprop="dateModified" datetime="2024-11-03T00:26:13+08:00">2024-11-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一、返回值"><a href="#一、返回值" class="headerlink" title="一、返回值"></a>一、返回值</h3><ul>
<li><p>Rust 是一个类型安全的语言，这意味着返回值是由返回值类型来决定的。</p>
</li>
<li><p>Rust 的返回值可以是任何类型，包括 <code>()</code> 空元组，或者是其他任何类型。</p>
</li>
</ul>
<h4 id="1-解构Option"><a href="#1-解构Option" class="headerlink" title="1. 解构Option&lt;T&gt;"></a>1. 解构<code>Option&lt;T&gt;</code></h4><ol>
<li>如果 <code>Option&lt;T&gt;</code> 包含值，返回包含的值。</li>
<li>如果 <code>Option&lt;T&gt;</code> 包含 <code>None</code>，返回 <code>None</code> 值。</li>
</ol>
<ul>
<li>一个变量要么有值，要么为空</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">six</span> = <span class="title function_ invoke__">plus_one</span>(five);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">none</span> = <span class="title function_ invoke__">plus_one</span>(<span class="literal">None</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>plus_one 接受一个 <code>Option&lt;i32&gt;</code> 类型的参数，同时返回一个 <code>Option&lt;i32&gt; </code>类型的值（这种形式的函数在标准库内随处所见），在该函数的内部处理中，如果传入的是一个<code> None</code> ，则返回一个 None 且不做任何处理；如果传入的是一个 <code>Some(i32)</code>，则通过模式绑定，把其中的值绑定到变量 <code>i</code> 上，然后返回 <code>i+1</code> 的值，同时用 <code>Some </code>进行包裹。</li>
</ul>
<h5 id="1-1-Option-的一些辅助函数"><a href="#1-1-Option-的一些辅助函数" class="headerlink" title="1.1 Option&lt;T&gt; 的一些辅助函数"></a>1.1 <code>Option&lt;T&gt;</code> 的一些辅助函数</h5><ol>
<li><code>unwrap</code>：返回 <code>Option&lt;T&gt;</code> 包含的值，如果 <code>Option&lt;T&gt;</code> 为空，返回 <code>panic</code>。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = s.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 返回Option&lt;char&gt;</span></span><br><span class="line">    <span class="comment">// 如果能够明确值存在，可以使用unwrap()</span></span><br><span class="line">    <span class="comment">// 有值的时候会取值，没值的时候panic</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p1); <span class="comment">// 输出 ‘o’</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用<code>is_some</code> 和 <code>is_none</code> ：返回 <code>bool</code> 值，判断 <code>Option&lt;T&gt;</code> 包含值或者为空。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];</span><br><span class="line">    <span class="keyword">if</span> v.<span class="title function_ invoke__">get</span>(<span class="number">1</span>).<span class="title function_ invoke__">is_some</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value at index 1 is: &#123;&#125;&quot;</span>, v[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>unwrap_or</code> ：返回 <code>Option&lt;T&gt;</code> 包含的值，如果 <code>Option&lt;T&gt;</code> 为空，返回一个提供的默认值</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">div</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">f64</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> b != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(a <span class="keyword">as</span> <span class="type">f64</span> / b <span class="keyword">as</span> <span class="type">f64</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">div</span>(a, b).<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0.0</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出 0.0</p>
</blockquote>
<h3 id="二、错误处理"><a href="#二、错误处理" class="headerlink" title="二、错误处理"></a>二、错误处理</h3><ul>
<li><p>错误对于软件来说是不可避免的，因此一门优秀的编程语言必须有其完整的错误处理哲学。在很多情况下，Rust 需要你承认自己的代码可能会出错，并提前采取行动，来处理这些错误。</p>
</li>
<li><p>Rust 中的错误主要分为两类：</p>
</li>
</ul>
<ol>
<li>可恢复错误，通常用于从系统全局角度来看可以接受的错误，例如处理用户的访问、操作等错误，这些错误只会影响某个用户自身的操作进程，而不会对系统的全局稳定性产生影响</li>
<li>不可恢复错误，刚好相反，该错误通常是全局性或者系统性的错误，例如数组越界访问，系统启动时发生了影响启动流程的错误等等，这些错误的影响往往对于系统来说是致命的</li>
</ol>
<ul>
<li>很多编程语言，并不会区分这些错误，而是直接采用异常的方式去处理。Rust 没有异常，但是 Rust 也有自己的卧龙凤雏：<code>Result&lt;T, E&gt; </code>用于可恢复错误，<code>panic! </code>用于不可恢复错误。</li>
</ul>
<h4 id="1-panic！"><a href="#1-panic！" class="headerlink" title="1. panic！"></a>1. panic！</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    v[<span class="number">99</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在上面的代码中，Rust 编译器会在 <code>v[99]</code> 这行代码中 panic，并在 panic 发生时终止程序。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling panic v0.<span class="number">1.0</span> (file:<span class="comment">///projects/panic)</span></span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.27</span>s</span><br><span class="line">     Running `target/debug/panic`</span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;index</span> out of bounds: the len is <span class="number">3</span> but the index is <span class="number">99</span>&#x27;, src/main.rs:<span class="number">4</span>:<span class="number">5</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="1-1-主动调用"><a href="#1-1-主动调用" class="headerlink" title="1.1 主动调用"></a>1.1 主动调用</h5><ol>
<li><code>panic!</code> ：在代码中主动 panic，可以传递一个字符串作为 panic 的消息。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;crash and burn&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行后输出:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;crash</span> and burn&#x27;, src/main.rs:<span class="number">2</span>:<span class="number">5</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>RUST_BACKTRACE=1 cargo run</code>，可以看调用栈</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;index</span> out of bounds: the len is <span class="number">3</span> but the index is <span class="number">99</span>&#x27;, src/main.rs:<span class="number">4</span>:<span class="number">5</span></span><br><span class="line">stack backtrace:</span><br><span class="line">   <span class="number">0</span>: rust_begin_unwind</span><br><span class="line">             at /rustc/<span class="number">59</span>eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/std/src/panicking.rs:<span class="number">517</span>:<span class="number">5</span></span><br><span class="line">   <span class="number">1</span>: core::panicking::panic_fmt</span><br><span class="line">             at /rustc/<span class="number">59</span>eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:<span class="number">101</span>:<span class="number">14</span></span><br><span class="line">   <span class="number">2</span>: core::panicking::panic_bounds_check</span><br><span class="line">             at /rustc/<span class="number">59</span>eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:<span class="number">77</span>:<span class="number">5</span></span><br><span class="line">   <span class="number">3</span>: &lt;<span class="type">usize</span> <span class="keyword">as</span> core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index</span><br><span class="line">             at /rustc/<span class="number">59</span>eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:<span class="number">184</span>:<span class="number">10</span></span><br><span class="line">   <span class="number">4</span>: core::slice::index::&lt;<span class="keyword">impl</span> <span class="title class_">core</span>::ops::index::Index&lt;I&gt; <span class="keyword">for</span> [T]&gt;::index</span><br><span class="line">             at /rustc/<span class="number">59</span>eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:<span class="number">15</span>:<span class="number">9</span></span><br><span class="line">   <span class="number">5</span>: &lt;alloc::vec::<span class="type">Vec</span>&lt;T,A&gt; <span class="keyword">as</span> core::ops::index::Index&lt;I&gt;&gt;::index</span><br><span class="line">             at /rustc/<span class="number">59</span>eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/alloc/src/vec/<span class="keyword">mod</span>.rs:<span class="number">2465</span>:<span class="number">9</span></span><br><span class="line">   <span class="number">6</span>: world_hello::main</span><br><span class="line">             at ./src/main.rs:<span class="number">4</span>:<span class="number">5</span></span><br><span class="line">   <span class="number">7</span>: core::ops::function::<span class="built_in">FnOnce</span>::call_once</span><br><span class="line">             at /rustc/<span class="number">59</span>eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/ops/function.rs:<span class="number">227</span>:<span class="number">5</span></span><br><span class="line">note: <span class="literal">Some</span> details are omitted, run with `RUST_BACKTRACE=full` <span class="keyword">for</span> <span class="title class_">a</span> verbose backtrace.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>它包含了函数调用的顺序，当然按照逆序排列：最近调用的函数排在列表的最上方</li>
</ul>
<h4 id="2-Result"><a href="#2-Result" class="headerlink" title="2. Result&lt;T, E&gt;"></a>2. Result&lt;T, E&gt;</h4><ul>
<li>Result 是一个枚举，可以是 Ok(T)，也可以是 Err(E)。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们举一个例子</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">div</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">f64</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> b != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(a <span class="keyword">as</span> <span class="type">f64</span> / b <span class="keyword">as</span> <span class="type">f64</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="string">&quot;b cannot be zero&quot;</span>.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sqrt</span>(x: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">f64</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="string">&quot;x cannot be negative&quot;</span>.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(x.<span class="title function_ invoke__">sqrt</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们还可以定义错误的枚举类型</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MathError</span> &#123;</span><br><span class="line">    DivisionByZero,</span><br><span class="line">    NegativeNumber,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">div</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">f64</span>, MathError&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> b != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(a <span class="keyword">as</span> <span class="type">f64</span> / b <span class="keyword">as</span> <span class="type">f64</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(MathError::DivisionByZero)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sqrt</span>(x: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">f64</span>, MathError&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(MathError::NegativeNumber)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(x.<span class="title function_ invoke__">sqrt</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>举例子处理Result，以标准库中对文件的处理为例</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Error opening file: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>对返回的错误进行处理</p>
</li>
<li><p>我们希望对不同的错误原因采取不同的处理方式</p>
</li>
</ul>
<ol>
<li>如果 <code>File::open</code> 因为文件不存在而报错，我们希望创建文件并返回新文件的句柄。</li>
<li>如果 <code>File::open</code> 因为其他的错误而报错，我们希望继续<code>panic！</code>。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file_result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = <span class="keyword">match</span> greeting_file_result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">                ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                    <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                    <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Couldn&#x27;t create the file: &#123;&#125;&quot;</span>, e),</span><br><span class="line">                &#125;,</span><br><span class="line">                other_error =&gt; &#123;</span><br><span class="line">                    <span class="built_in">panic!</span>(<span class="string">&quot;Couldn&#x27;t open the file: &#123;&#125;&quot;</span>, error);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-1-Result-的辅助函数"><a href="#2-1-Result-的辅助函数" class="headerlink" title="2.1 Result&lt;T, E&gt; 的辅助函数"></a>2.1 Result&lt;T, E&gt; 的辅助函数</h5><ol>
<li><p><code>unwrap()</code> 和 <code>unwrap_or()</code>： <code>unwrap()</code> 用于从 <code>Result&lt;T, E&gt;</code> 中获取 <code>T</code> 值，如果<code>Result</code>为空，则 <code>panic</code>。<code>unwrap_or()</code> 用于从 <code>Result&lt;T, E&gt; </code>中获取 T 值，如果 <code>Result</code> 为空，则返回提供的默认值。</p>
</li>
<li><p><code>expect()</code>：<code>expect()</code> 用于从 <code>Result&lt;T, E&gt; </code>中获取 <code>T</code> 值，如果 <code>Result</code> 为空，则 <code>panic</code> 并返回提供的 <code>panic</code> 消息。</p>
</li>
<li><p><code>map</code> : 在<code>Result&lt;T,E&gt;</code> 中对 <code>T </code>值进行处理，返回 <code>Result&lt;U, E&gt;</code>。</p>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">line</span> = <span class="string">&quot;1\n2\n3\n4\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> line.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">match</span> num.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">map</span>(|i| i * <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, num);</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(..) =&gt; &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>map_err</code> : 在 <code>Result&lt;T,E&gt;</code> 中对 <code>E</code> 值进行处理，返回 <code>Result&lt;T, F&gt;</code>。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">x</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">map_err</span>(|e: std::io::Error| <span class="punctuation">-&gt;</span><span class="type">String</span> &#123;<span class="built_in">format!</span>(<span class="string">&quot;Error opening file: &#123;&#125;&quot;</span>, e)&#125;);</span><br><span class="line">    <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(()),</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>在代码运行时，代码是向上层函数传播错误的</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>为了简便，传播错误可以使用简写运算符<code>?</code></p>
</li>
<li><p>对于<code>Result</code> 如果结果是<code>Ok(T)</code>， 则把<code>T</code>赋值给<code>f</code></p>
</li>
<li><p>对于<code>Result</code> 如果结果是<code>Err(E)</code>， 则返回 <code>Err(E)</code></p>
</li>
<li><p>对于<code>Option</code>如果值是<code>Some</code>，<code>Some</code>中的值作为表达式的返回值同时函数继续</p>
</li>
<li><p>如果值是<code>None</code> 则此时<code>None</code>会从函数中提前返回</p>
</li>
<li><p>所以<code>?</code>特别适合用来传播错误</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-Option-和-Result-之间的转换"><a href="#3-Option-和-Result-之间的转换" class="headerlink" title="3. Option 和 Result&lt;T, E&gt; 之间的转换"></a>3. Option<T> 和 Result&lt;T, E&gt; 之间的转换</h4><ol>
<li><code>Option&lt;T&gt;</code> 转 <code>Result&lt;T, E&gt;</code>：</li>
</ol>
<p><code>ok_or</code>：</p>
<ul>
<li><code>Some(t)</code> 转 <code>Ok(t)</code></li>
<li><code>None</code> 转 <code>Err(e)</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first</span>(arr:&amp;[<span class="type">i32</span>] <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;&amp;<span class="type">i32</span>, <span class="type">String</span>&gt;) &#123;</span><br><span class="line">    arr.<span class="title function_ invoke__">get</span>(<span class="number">0</span>).<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;out of bounds&quot;</span>.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>err</code>:</p>
<ul>
<li><code>Err(e)</code> 转 <code>Some(e)</code></li>
<li><code>Ok(e)</code> 转 <code>None</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">err</span>();</span><br><span class="line">    <span class="keyword">if</span> f.<span class="title function_ invoke__">is_some</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;no file found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 输出 no file found</span></span><br></pre></td></tr></table></figure>

<p><code>ok</code>:</p>
<ul>
<li><code>Err(e)</code> 转 <code>None</code></li>
<li><code>Ok(e)</code> 转 <code>Some(e)</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">err</span>();</span><br><span class="line">    <span class="keyword">if</span> f.<span class="title function_ invoke__">is_none</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;no file found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 输出 no file found</span></span><br></pre></td></tr></table></figure>









      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/02/Seventh_chapter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kunqi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0xkunqil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/02/Seventh_chapter/" class="post-title-link" itemprop="url">Rust基础：结构体</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-11-02 18:17:25 / Modified: 22:18:41" itemprop="dateCreated datePublished" datetime="2024-11-02T18:17:25+08:00">2024-11-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-定义结构体"><a href="#1-定义结构体" class="headerlink" title="1. 定义结构体"></a>1. 定义结构体</h3><p>Rust 的结构体是一组命名的值，可以让你创建拥有特定功能的自定义数据类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 每一个字段都必须初始化，没有默认赋值</span></span><br><span class="line">    <span class="comment">// 字段的赋值顺序和定义顺序不需要一致</span></span><br><span class="line">    <span class="comment">// 字段名使用逗号分隔</span></span><br><span class="line">    <span class="comment">// 字段名和类型定义在同一行</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;john.doe@example.com&quot;</span>),</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;john_doe&quot;</span>),</span><br><span class="line">        sign_in_count: <span class="number">10</span>,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>类似js里，当类型名和字段名一样的时候可以省略</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">email</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;john.doe@example.com&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">username</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;john_doe&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        sign_in_count: <span class="number">10</span>,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-一个实例给另一个实例赋值"><a href="#2-一个实例给另一个实例赋值" class="headerlink" title="2. 一个实例给另一个实例赋值"></a>2. 一个实例给另一个实例赋值</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">email</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;john.doe@example.com&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">username</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;john_doe&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">    email,</span><br><span class="line">    username,</span><br><span class="line">    sign_in_count: <span class="number">10</span>,</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jane.doe@example.com&quot;</span>),</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jane_doe&quot;</span>),</span><br><span class="line">    ..user1 <span class="comment">// 没有逗号，结构更新语法，代表继承user1其余值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以用 user1.email 取值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-对结构体字段进行修改"><a href="#3-对结构体字段进行修改" class="headerlink" title="3. 对结构体字段进行修改"></a>3. 对结构体字段进行修改</h3><ul>
<li>首先我们对结构体字段进行修改，需要将结构体实例定义为可写<code>mut</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = User &#123;</span><br><span class="line">    email,</span><br><span class="line">    username,</span><br><span class="line">    sign_in_count: <span class="number">10</span>,</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user1.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;new@example.com&quot;</span>);</span><br><span class="line">user1.username = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;john_doe_updated&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-不具名字段"><a href="#4-不具名字段" class="headerlink" title="4. 不具名字段"></a>4. 不具名字段</h3><ul>
<li><p>元组结构体</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Black: (&#123;&#125;, &#123;&#125;, &#123;&#125;), Origin: (&#123;&#125;, &#123;&#125;, &#123;&#125;)&quot;</span>, black.<span class="number">0</span>, black.<span class="number">1</span>, black.<span class="number">2</span>, origin.<span class="number">0</span>, origin.<span class="number">1</span>, origin.<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单元结构体</p>
</li>
<li><p>定义一个类型但是不在乎类型的内容，可以使用单元结构体</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AlwaysEqual</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">subject</span> = AlwaysEqual;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">SomeTrait</span> <span class="keyword">for</span> <span class="title class_">AlwaysEqual</span> &#123;</span><br><span class="line">    <span class="comment">// 实现 SomeTrait 并不提供任何内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-结构体所有权"><a href="#5-结构体所有权" class="headerlink" title="5. 结构体所有权"></a>5. 结构体所有权</h3><ol>
<li>结构体的所有权是在字段范围内成立的</li>
<li>对于基本类型的字段，由于实现了copy特性，所以不会发生所有权的转移，而是发生赋值</li>
<li>一旦结构体中某一个字段发生了所有权的移动，整个结构体就不能再被赋值了，但是可以单独使用未发生所有权转移的字段</li>
<li>对于结构体更新语法，所有权转移规则依旧成立</li>
</ol>
<h3 id="6-结构体方法"><a href="#6-结构体方法" class="headerlink" title="6. 结构体方法"></a>6. 结构体方法</h3><ul>
<li>方法与函数是不同的，方法需要在结构体上定义，并且需要在 <code>impl</code> 关键字后面指定所属的结构体，方法的第一个参数是 <code>self</code>，代表调用该方法的结构体实例。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect</span> = Rectangle &#123; width: <span class="number">30</span>, height: <span class="number">50</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Area: &#123;&#125;&quot;</span>, rect.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Rust 允许我们为一个结构体定义多个<code>impl</code> 块，这可以让我们在同一个结构体上实现多个方法，以便更灵活地使用。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-实现trait"><a href="#7-实现trait" class="headerlink" title="7. 实现trait"></a>7. 实现trait</h3><ul>
<li>如果不同类型具有相同的行为，我们可以定义一个特征，然后为这些类型实现该特征。</li>
<li>定义特征是把一些方法组合在一起，目的是定义一个实现某些目标所必须的行为的集合。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">f64</span>,</span><br><span class="line">    height: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Shape</span> <span class="keyword">for</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Shape</span> <span class="keyword">for</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        std::<span class="type">f64</span>::consts::PI * <span class="keyword">self</span>.radius * <span class="keyword">self</span>.radius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_area</span>(shape: &amp;<span class="keyword">impl</span> <span class="title class_">Shape</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Area: &#123;&#125;&quot;</span>, shape.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125; <span class="comment">// 既能打印长方形，也能打印圆形</span></span><br></pre></td></tr></table></figure>





      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/21/Sixth_chapter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kunqi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0xkunqil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/21/Sixth_chapter/" class="post-title-link" itemprop="url">Rust基础：枚举类型和模式匹配</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-21 21:37:04" itemprop="dateCreated datePublished" datetime="2024-10-21T21:37:04+08:00">2024-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-02 18:12:59" itemprop="dateModified" datetime="2024-11-02T18:12:59+08:00">2024-11-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-定义枚举"><a href="#1-定义枚举" class="headerlink" title="1. 定义枚举"></a>1. 定义枚举</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    North,</span><br><span class="line">    South,</span><br><span class="line">    East,</span><br><span class="line">    West,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">direction</span>: Direction = Direction::North;</span><br></pre></td></tr></table></figure>

<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>枚举构造器可以带有具名字段或未具名字段：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Dog</span>(<span class="type">String</span>, <span class="type">f64</span>),</span><br><span class="line">    Cat &#123; name: <span class="type">String</span>, weight: <span class="type">f64</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span>: Animal = Animal::<span class="title function_ invoke__">Dog</span>(<span class="string">&quot;Cocoa&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">37.2</span>);</span><br><span class="line">a = Animal::Cat &#123; name: <span class="string">&quot;Spotty&quot;</span>.<span class="title function_ invoke__">to_string</span>(), weight: <span class="number">2.7</span> &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>在这个例子中，<code>Cat</code> 是一个类结构体枚举变体<code>(struct-like enum variant)</code>，而<code> Dog</code> 则被简单地称为枚举变体。每个枚举实例都有一个判别值&#x2F;判别式(discriminant)，它是一个与此枚举实例关联的整数，用来确定它持有哪个变体。</li>
</ul>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><ul>
<li><p><code>match</code> vs <code>if let</code></p>
</li>
<li><p><code>match</code> 匹配器可以用来检查枚举的判别值，并执行相应的代码分支,必须匹配所有条件。完整匹配才能编译成功。</p>
</li>
<li><p>解构色彩模型例子</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要 `allow` 来消除警告，因为只使用了枚举类型的一种取值。</span></span><br><span class="line"><span class="meta">#[allow(dead_code)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="comment">// 这三个取值仅由它们的名字（而非类型）来指定。</span></span><br><span class="line">    Red,</span><br><span class="line">    Blue,</span><br><span class="line">    Green,</span><br><span class="line">    <span class="comment">// 这些则把 `u32` 元组赋予不同的名字，以色彩模型命名。</span></span><br><span class="line">    <span class="title function_ invoke__">RGB</span>(<span class="type">u32</span>, <span class="type">u32</span>, <span class="type">u32</span>),</span><br><span class="line">    <span class="title function_ invoke__">HSV</span>(<span class="type">u32</span>, <span class="type">u32</span>, <span class="type">u32</span>),</span><br><span class="line">    <span class="title function_ invoke__">HSL</span>(<span class="type">u32</span>, <span class="type">u32</span>, <span class="type">u32</span>),</span><br><span class="line">    <span class="title function_ invoke__">CMY</span>(<span class="type">u32</span>, <span class="type">u32</span>, <span class="type">u32</span>),</span><br><span class="line">    <span class="title function_ invoke__">CMYK</span>(<span class="type">u32</span>, <span class="type">u32</span>, <span class="type">u32</span>, <span class="type">u32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">color</span> = Color::<span class="title function_ invoke__">RGB</span>(<span class="number">122</span>, <span class="number">17</span>, <span class="number">40</span>);</span><br><span class="line">    <span class="comment">// 试一试 ^ 将不同的值赋给 `color`</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;What color is it?&quot;</span>);</span><br><span class="line">    <span class="comment">// 可以使用 `match` 来解构 `enum`。</span></span><br><span class="line">    <span class="keyword">match</span> color &#123;</span><br><span class="line">        Color::Red   =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The color is Red!&quot;</span>),</span><br><span class="line">        Color::Blue  =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The color is Blue!&quot;</span>),</span><br><span class="line">        Color::Green =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The color is Green!&quot;</span>),</span><br><span class="line">        Color::<span class="title function_ invoke__">RGB</span>(r, g, b) =&gt;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Red: &#123;&#125;, green: &#123;&#125;, and blue: &#123;&#125;!&quot;</span>, r, g, b),</span><br><span class="line">        Color::<span class="title function_ invoke__">HSV</span>(h, s, v) =&gt;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Hue: &#123;&#125;, saturation: &#123;&#125;, value: &#123;&#125;!&quot;</span>, h, s, v),</span><br><span class="line">        Color::<span class="title function_ invoke__">HSL</span>(h, s, l) =&gt;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Hue: &#123;&#125;, saturation: &#123;&#125;, lightness: &#123;&#125;!&quot;</span>, h, s, l),</span><br><span class="line">        Color::<span class="title function_ invoke__">CMY</span>(c, m, y) =&gt;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Cyan: &#123;&#125;, magenta: &#123;&#125;, yellow: &#123;&#125;!&quot;</span>, c, m, y),</span><br><span class="line">        Color::<span class="title function_ invoke__">CMYK</span>(c, m, y, k) =&gt;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Cyan: &#123;&#125;, magenta: &#123;&#125;, yellow: &#123;&#125;, key (black): &#123;&#125;!&quot;</span>,</span><br><span class="line">                c, m, y, k),</span><br><span class="line">        <span class="comment">// 不需要其它分支，因为所有的情形都已覆盖</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在一些场景下，用match匹配枚举类型并不够优雅，可以用 <code>if let</code> 来实现。</li>
</ul>
<p>例如</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="comment">// 将 `optional` 定为 `Option&lt;i32&gt;` 类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">optional</span> = <span class="title function_ invoke__">Some</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> optional &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(i) =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;This is a really long string and `&#123;:?&#125;`&quot;</span>, i);</span><br><span class="line">        <span class="comment">// ^ 行首需要 2 层缩进。这里从 optional 中解构出 `i`。</span></span><br><span class="line">        <span class="comment">// 译注：正确的缩进是好的，但并不是 “不缩进就不能运行” 这个意思。</span></span><br><span class="line">    &#125;,</span><br><span class="line">    _ =&gt; &#123;&#125;,</span><br><span class="line">    <span class="comment">// ^ 必须有，因为 `match` 需要覆盖全部情况。不觉得这行很多余吗？</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们可以使用if let</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 全部都是 `Option&lt;i32&gt;` 类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">letter</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">emoticon</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `if let` 结构读作：若 `let` 将 `number` 解构成 `Some(i)`，则执行</span></span><br><span class="line">    <span class="comment">// 语句块（`&#123;&#125;`）</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(i) = number &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Matched &#123;:?&#125;!&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要指明失败情形，就使用 else：</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(i) = letter &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Matched &#123;:?&#125;!&quot;</span>, i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 解构失败。切换到失败情形。</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Didn&#x27;t match a number. Let&#x27;s go with a letter!&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供另一种失败情况下的条件。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i_like_letters</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(i) = emoticon &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Matched &#123;:?&#125;!&quot;</span>, i);</span><br><span class="line">    <span class="comment">// 解构失败。使用 `else if` 来判断是否满足上面提供的条件。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> i_like_letters &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Didn&#x27;t match a number. Let&#x27;s go with a letter!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 条件的值为 false。于是以下是默认的分支：</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;I don&#x27;t like letters. Let&#x27;s go with an emoticon :)!&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>if let 可以匹配任意枚举值</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以这个 enum 类型为例</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    Bar,</span><br><span class="line">    Baz,</span><br><span class="line">    <span class="title function_ invoke__">Qux</span>(<span class="type">u32</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Foo::Bar;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Foo::Baz;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = Foo::<span class="title function_ invoke__">Qux</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变量 a 匹配到了 Foo::Bar</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Foo</span>::Bar = a &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;a is foobar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变量 b 没有匹配到 Foo::Bar，因此什么也不会打印。</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Foo</span>::Bar = b &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;b is foobar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变量 c 匹配到了 Foo::Qux，它带有一个值，就和上面例子中的 Some() 类似。</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Foo</span>::<span class="title function_ invoke__">Qux</span>(value) = c &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;c is &#123;&#125;&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-Option"><a href="#2-Option" class="headerlink" title="2. Option"></a>2. Option</h3><ul>
<li>Option 是一个标准库中枚举类型，可以有 <code>Some</code> 值和 <code>None</code> 值，Option 类型应用广泛因为它编码了一个非常普遍的场景，即一个值要么有值要么没值。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>只要一个值不是 Option<T> 类型，你就 可以 安全的认定它的值不为空。这是 Rust 的一个经过深思熟虑的设计决策，来限制空值的泛滥以增加 Rust 代码的安全性。</li>
</ul>
<h3 id="3-Result"><a href="#3-Result" class="headerlink" title="3. Result"></a>3. Result</h3><ul>
<li>Result&lt;T, E&gt; 是一个标准库中枚举类型，可以有 <code>Ok</code> 值和 <code>Err</code> 值，Result 常用来处理可以恢复的错误。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code> 代表成功时返回的 <code>Ok</code> 成员中的数据的类型，而 <code>E</code> 代表失败时返回的 <code>Err</code> 成员中的错误的类型</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/21/Fifth-chapter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kunqi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0xkunqil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/21/Fifth-chapter/" class="post-title-link" itemprop="url">Rust基础:字符串</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-10-21 20:44:52 / Modified: 21:33:26" itemprop="dateCreated datePublished" datetime="2024-10-21T20:44:52+08:00">2024-10-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-字符串类型"><a href="#1-字符串类型" class="headerlink" title="1. 字符串类型"></a>1. 字符串类型</h3><p>Rust 中有两种字符串类型：String 和 &amp;str。</p>
<ul>
<li><p>String 被存储为由字节组成的 vector（Vec<u8>），但保证了它一定是一个有效的 UTF-8 序列。String 是堆分配的，可增长的，且不是零结尾的（null terminated）。</p>
</li>
<li><p>&amp;str 是一个总是指向有效 UTF-8 序列的切片（&amp;[u8]），并可用来查看 String 的内容，就如同 &amp;[T] 是 Vec<T> 的全部或部分引用。</p>
</li>
<li><p>从 String 类型转换为 &amp;str 类型非常便捷，性能无损，所以许多接收参数是String引用的函数会使用&amp;str 类型作为函数入参。</p>
</li>
</ul>
<h3 id="2-创建-String"><a href="#2-创建-String" class="headerlink" title="2. 创建 String"></a>2. 创建 String</h3><ol>
<li>字面值：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;Hello, world!&quot;</span>; <span class="comment">// 字面值是一个切片，&amp;str 类型</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>构造字符串：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, world!&quot;</span>); <span class="comment">// String 类型</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>迭代器：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;Hello, world!&quot;</span>.<span class="title function_ invoke__">chars</span>(); <span class="comment">// 迭代器返回一个迭代器，元素是字符</span></span><br></pre></td></tr></table></figure>

<h3 id="3-字符串操作"><a href="#3-字符串操作" class="headerlink" title="3. 字符串操作"></a>3. 字符串操作</h3><ol>
<li><p>获取字符串长度：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s.<span class="title function_ invoke__">len</span>()); <span class="comment">// 13</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s.<span class="title function_ invoke__">len</span>()); <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串拼接：</p>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 组合字符串是最简单和直观的方法，尤其是在字符串和非字符串混合的情况下。</span></span><br><span class="line"> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = <span class="string">&quot;world!&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hw</span> = <span class="built_in">format!</span>(<span class="string">&quot;Hello &#123;&#125;!&quot;</span>, name);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, hw);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 在追加字符串的时候，可以使用`push_str`方法,`push_str`性能比`format!`更好</span></span><br><span class="line"> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hw</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    hw.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    hw.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; world!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, hw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 通过`concat()`方法将字符串数组拼接成一个字符串</span></span><br><span class="line"> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hw</span> = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;world!&quot;</span>].<span class="title function_ invoke__">concat</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, hw);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 通过`join()`方法将字符串数组拼接成一个字符串</span></span><br><span class="line"> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hw_1</span> = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world!&quot;</span>].<span class="title function_ invoke__">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, hw_1);</span><br><span class="line">    <span class="comment">// 输出：</span></span><br><span class="line">    <span class="comment">// helloworld!</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用`join()`方法在拼接字符串时添加或指定字符</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hw_2</span> = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world!&quot;</span>].<span class="title function_ invoke__">join</span>(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, hw_2);</span><br><span class="line">    <span class="comment">// 输出：</span></span><br><span class="line">    <span class="comment">// hello+world!</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 使用`collect()`方式对数组中的字符串进行拼接</span></span><br><span class="line"> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hw</span> = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;world!&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span>: <span class="type">String</span> = hw.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| *x).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, res);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 使用符号`+`进行字符串拼接</span></span><br><span class="line"> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hw_1</span> = &amp;(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>) + &amp;<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot; &quot;</span>) + &amp;<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world!&quot;</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, hw_1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hw_2</span> = &amp;(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>) + <span class="string">&quot; &quot;</span> + <span class="string">&quot;world!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, hw_2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hw_3</span> = &amp;(<span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_owned</span>() + <span class="string">&quot; &quot;</span> + <span class="string">&quot;world!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, hw_3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hw_4</span> = &amp;(<span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>() + <span class="string">&quot; &quot;</span> + <span class="string">&quot;world!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, hw_4);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-replace方法："><a href="#4-replace方法：" class="headerlink" title="4. replace方法："></a>4. replace方法：</h3><ul>
<li>replace 方法可以将一个子字符串替换为另一个子字符串,返回新的字符串</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s); <span class="comment">// Output: Hello, world!</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = s.<span class="title function_ invoke__">replace</span>(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;rust&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s1); <span class="comment">// Output: Hello, rust!</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>replacen 多一个替换数量的入参</li>
</ul>
<h3 id="5-insert-和-insert-str-方法："><a href="#5-insert-和-insert-str-方法：" class="headerlink" title="5. insert() 和 insert_str() 方法："></a>5. insert() 和 insert_str() 方法：</h3><ol>
<li><p>insert() 方法在指定位置插入一个字符:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello,world!&quot;</span>);</span><br><span class="line">s.<span class="title function_ invoke__">insert</span>(<span class="number">6</span>,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s); <span class="comment">// Output: Hello, world!</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>insert_str() 方法在指定位置插入一个字符串:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">s.<span class="title function_ invoke__">insert_str</span>(<span class="number">6</span>, <span class="string">&quot; Rust&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s); <span class="comment">// Output: &quot;Hello, Rust world!&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>若插入超出范围，则字符串会增长</li>
</ul>
<h3 id="6-字符串转化"><a href="#6-字符串转化" class="headerlink" title="6. 字符串转化"></a>6. 字符串转化</h3><ol>
<li><p>转为字符数组：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">chars</span>: <span class="type">Vec</span>&lt;<span class="type">char</span>&gt; = s.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, chars); <span class="comment">// Output: [&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;,&#x27;,&#x27;&#x27;, &#x27;w&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d]</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 转为字符串 slice</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span>: &amp;<span class="type">str</span> = &amp;s2[..];</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, slice); <span class="comment">// Output: Hello, world!</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>转为 Vec<u8>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">bytes</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = s.<span class="title function_ invoke__">as_bytes</span>().<span class="title function_ invoke__">to_vec</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, bytes); <span class="comment">// Output: [72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33]</span></span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/21/Forth_chapter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kunqi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0xkunqil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/21/Forth_chapter/" class="post-title-link" itemprop="url">Rust基础:所有权、引用、数组与切片</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-10-21 19:46:57 / Modified: 20:45:04" itemprop="dateCreated datePublished" datetime="2024-10-21T19:46:57+08:00">2024-10-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-所有权"><a href="#1-所有权" class="headerlink" title="1 所有权"></a>1 所有权</h2><ul>
<li>Rust所有权规则可以总结为如下几句话：</li>
</ul>
<ol>
<li>Rust中的每个值都有一个被称为其所有者的变量(即：值的所有者是某个变量)</li>
<li>值在任一时刻有且只有一个所有者</li>
<li>当所有者(变量)离开作用域，这个值将被销毁</li>
</ol>
<ul>
<li>这里对第三点做一些补充性的解释，所有者离开作用域会导致值被销毁，这个过程实际上是调用一个名为drop的函数来销毁数据释放内存。在前文解释作用域规则时曾提到过，销毁的数据特指堆栈中的数据，如果变量绑定的值是全局内存区内的数据，则数据不会被销毁。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>脱离作用域时，S就会被销毁</li>
</ul>
<h3 id="1-1谁是谁的所有者"><a href="#1-1谁是谁的所有者" class="headerlink" title="1.1谁是谁的所有者"></a>1.1谁是谁的所有者</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>多数人可能会误以为变量s是堆中字符串数据hello的所有者，但实际上不是。</p>
</li>
<li><p>前面介绍内存的文章中解释过，String字符串的实际数据在堆中，但是String大小不确定，所以在栈中使用一个胖指针结构来表示这个String类型的数据，这个胖指针中的指针指向堆中的String实际数据。也就是说，变量s的值是那个胖指针，而不是堆中的实际数据。</p>
</li>
<li><p>因此，变量s是那个胖指针的所有者，而不是堆中实际数据的所有者。</p>
</li>
<li><p>但是，由于胖指针是指向堆中数据的，多数时候为了简化理解简化描述方式，也经常会说s是那个堆中实际数据的所有者。</p>
</li>
</ul>
<h3 id="1-2-指针的绑定"><a href="#1-2-指针的绑定" class="headerlink" title="1.2 指针的绑定"></a>1.2 指针的绑定</h3><ul>
<li>在其他语言中，经常可以看到两个不同的指针指向同一块内存的情况。</li>
<li>但在Rust中，由于所有权的规则，变量跳出作用域后释放堆中的值，等两个不同指针也相应释放时，就会造成二次释放内存污染。</li>
<li>所以对于Rust中：<blockquote>
<p>let s2 &#x3D; s1;</p>
</blockquote>
</li>
</ul>
<p>直接让s1变成未初始化变量，而将s2绑定在堆内存上，这样就发生了一次所有权的转移。</p>
<p>所有权移动后修改数据：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// x将所有权转移给y，但y无法修改字符串</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;   </span><br><span class="line">y.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;C&#x27;</span>);  <span class="comment">// 本行报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">// 虽然a无法修改字符串，但转移所有权后，b可修改字符串</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> = a; </span><br><span class="line">b.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;C&#x27;</span>);   <span class="comment">// 本行不报错</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-引用和所有权借用"><a href="#1-3-引用和所有权借用" class="headerlink" title="1.3 引用和所有权借用"></a>1.3 引用和所有权借用</h3><ul>
<li>所有权不仅可以转移(原变量会丢失数据的所有权)，还可以通过引用的方式来借用数据的所有权(borrow ownership)。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = &amp;s; <span class="comment">// 借用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = &amp;s; <span class="comment">// 再次借用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>,s, s1, s2);</span><br><span class="line">  &#125;  <span class="comment">// sf2离开，sf1离开，s离开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&amp;s</code>表示创建变量s的引用，为某个变量创建引用的过程不会转移该变量所拥有的所有权。</p>
<h3 id="1-4-可变引用和不可变引用的所有权规则"><a href="#1-4-可变引用和不可变引用的所有权规则" class="headerlink" title="1.4 可变引用和不可变引用的所有权规则"></a>1.4 可变引用和不可变引用的所有权规则</h3><p>变量的引用分为可变引用&amp;mut var和不可变引用&amp;var，站在所有权借用的角度来看，可变引用表示的是可变借用，不可变引用表示的是不可变借用。</p>
<ol>
<li>不可变借用：借用只读权，不允许修改其引用的数据</li>
<li>可变引用：借用可写权(包括可读权)，允许修改其引用的数据</li>
<li>多个不可变引用可共存(可同时读)</li>
<li>可变引用具有排他性，在有可变引用时，不允许存在该数据的其他可变和不可变引用</li>
</ol>
<p>如要使用可变引用去修改数据值，要求：</p>
<p>var的变量可变，即<code>let mut var = xxx</code><br>var的引用可变，即<code>let varf = &amp;mut var</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;junmajinlong&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">x_ref</span> = &amp;<span class="keyword">mut</span> x;  <span class="comment">// 借用s的可写权</span></span><br><span class="line">  x_ref.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;.com&quot;</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="title function_ invoke__">f1</span>(&amp;<span class="keyword">mut</span> s);   <span class="comment">// 借用s的可写权</span></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f1</span>(s: &amp;<span class="keyword">mut</span> <span class="type">String</span>)&#123;</span><br><span class="line">  s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-数组"><a href="#2-数组" class="headerlink" title="2 数组"></a>2 数组</h2><ul>
<li>Rust中的数组是一段连续的内存区域，可以存储同一类型的数据。</li>
<li>数组有固定的大小，一旦定义好，就无法改变其大小。</li>
<li>数组在 Rust中是值类型，在栈中存储。</li>
<li>数组中的每个元素的类型必须相同。</li>
</ul>
<h3 id="2-1-创建和使用数组"><a href="#2-1-创建和使用数组" class="headerlink" title="2.1 创建和使用数组"></a>2.1 创建和使用数组</h3><ol>
<li>创建数组<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>:[<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; <span class="comment">// 在方括号中包含每个元素的类型，后跟分号，再后跟数组元素的数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>还可以通过在方括号中指定初始值加分号再加元素个数的方式来创建一个每个元素都为相同值的数组：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = [<span class="number">0</span>; <span class="number">5</span>]; <span class="comment">// 数组c中每一项都为0</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>数组元素的访问</li>
</ol>
<ul>
<li>数组是可以在栈 (stack) 上分配的已知固定大小的单个内存块。可以使用索引来访问数组的元素:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The first element is &#123;&#125;&quot;</span>, a[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>数组的长度</li>
</ol>
<ul>
<li>Rust 数组有固定的长度，所以可以直接使用 <code>len()</code> 方法来获取数组的长度:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The array has &#123;&#125; elements.&quot;</span>, a.<span class="title function_ invoke__">len</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>数组元素的修改</li>
</ol>
<ul>
<li>Rust 数组是值类型，所以在函数中修改数组元素的值并返回，需要使用借用和克隆:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="title function_ invoke__">change_array</span>(&amp;<span class="keyword">mut</span> a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = b.<span class="title function_ invoke__">to_vec</span>(); <span class="comment">// 克隆数组</span></span><br><span class="line">    <span class="title function_ invoke__">change_array</span>(&amp;<span class="keyword">mut</span> c);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change_array</span>(arr: &amp;<span class="keyword">mut</span> [<span class="type">i32</span>]) &#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-切片"><a href="#3-切片" class="headerlink" title="3 切片"></a>3 切片</h2><ul>
<li>切片是一段连续的数组的引用，可以对切片进行操作而不必对原始数组进行操作。</li>
</ul>
<h3 id="3-1-创建和使用切片"><a href="#3-1-创建和使用切片" class="headerlink" title="3.1 创建和使用切片"></a>3.1 创建和使用切片</h3><ol>
<li>创建切片</li>
</ol>
<ul>
<li>切片可以通过在方括号中指定开始和结束的索引来创建:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span> = &amp;a[<span class="number">1</span>..<span class="number">4</span>]; <span class="comment">// 开始索引为1，结束索引为4</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice2</span> = &amp;a[<span class="number">1</span>..]; <span class="comment">// 等同于 slice1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice3</span> = &amp;a[..<span class="number">4</span>]; <span class="comment">// 等同于 slice2</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice4</span> = &amp;a[..]; <span class="comment">// 等同于 slice3</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, slice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>切片的元素的访问</li>
</ol>
<ul>
<li>切片是可以直接使用索引来访问元素的:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">slice</span> = &amp;a[<span class="number">1</span>..<span class="number">4</span>];</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;The second element is &#123;&#125;&quot;</span>, slice[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>切片的长度</li>
</ol>
<ul>
<li>Rust 切片有固定的长度，所以可以直接使用 <code>len()</code> 方法来获取切片的长度:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">slice</span> = &amp;a[<span class="number">1</span>..<span class="number">4</span>];</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;The slice has &#123;&#125; elements.&quot;</span>, slice.<span class="title function_ invoke__">len</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>切片元素的修改</li>
</ol>
<ul>
<li>Rust 切片是值类型，所以在函数中修改切片元素的值并返回，需要使用借用和克隆:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">  <span class="title function_ invoke__">change_slice</span>(&amp;<span class="keyword">mut</span> a[<span class="number">1</span>..<span class="number">4</span>]);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">b</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">c</span> = b.<span class="title function_ invoke__">to_vec</span>(); <span class="comment">// 克隆切片</span></span><br><span class="line">  <span class="title function_ invoke__">change_slice</span>(&amp;<span class="keyword">mut</span> c);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change_slice</span>(slice: &amp;<span class="keyword">mut</span> [<span class="type">i32</span>]) &#123;</span><br><span class="line">  slice[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个小练习：</p>
<ul>
<li>给定一个整数数组nums，返回一个answer，使得返回的answer[i]等于除nums[i]之外nums中每一个元素的乘积。</li>
<li>示例：</li>
</ul>
<blockquote>
<p>Input: nums &#x3D; [1,2,3,4]<br>Output: [24,12,8,6]  </p>
</blockquote>
<blockquote>
<p>Input: nums &#x3D; [-1,1,0,-3,3]<br>Output: [0,0,9,0,0]  </p>
</blockquote>
<ul>
<li><p>注意：</p>
</li>
<li><p>除法取整以后的结果在 <code>[INT_MIN, INT_MAX]</code> 范围内。</p>
</li>
<li><p>要求：</p>
</li>
<li><p>时间复杂度为 O(n)</p>
</li>
<li><p>空间复杂度为 O(1)</p>
</li>
</ul>
<p>解法1:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_product_without_element</span>(arr: &amp;[<span class="type">i32</span>], index: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> index &gt;= arr.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">       <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mut_product</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..arr.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">      <span class="keyword">if</span> i == index &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      mut_product *= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="title function_ invoke__">Some</span>(mut_product)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法2:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_product_without_element</span>(arr: &amp;[<span class="type">i32</span>], index: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt;= arr.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">       <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">total_product</span> = arr.<span class="title function_ invoke__">iter</span>().product::&lt;<span class="type">i32</span>&gt;();</span><br><span class="line">    <span class="keyword">if</span> arr[index] == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> arr.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">filter</span>(|&amp;&amp;x| x == <span class="number">0</span>).<span class="title function_ invoke__">count</span>() &gt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="number">0</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> arr.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">filter</span>(|&amp;&amp;x| x == <span class="number">0</span>).<span class="title function_ invoke__">count</span>() == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(arr.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">filter</span>(|&amp;&amp;x| x!= <span class="number">0</span>).<span class="title function_ invoke__">product</span>()) </span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_ invoke__">Some</span>(total_product / arr[index])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/19/Third_chapter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kunqi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0xkunqil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/19/Third_chapter/" class="post-title-link" itemprop="url">Rust基础:函数、流程控制等基本概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-19 21:06:32" itemprop="dateCreated datePublished" datetime="2024-10-19T21:06:32+08:00">2024-10-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-函数"><a href="#1-函数" class="headerlink" title="1 函数"></a>1 函数</h2><ul>
<li>在Rust里，不关心函数的位置，无论调用前后声明都可以。</li>
<li>函数命名的开头必须是字符或下划线，后面再跟数字等，函数名不能仅有一个下划线。</li>
<li>Rust习惯使用蛇形命名法，用下划线分割。</li>
</ul>
<h3 id="1-1有返回值的函数"><a href="#1-1有返回值的函数" class="headerlink" title="1.1有返回值的函数"></a>1.1有返回值的函数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add_two</span>(i:<span class="type">i32</span>, j:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    i + j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上写法等价于：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add_two</span>(i:<span class="type">i32</span>, j:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意省略return后是没有<code>;</code>的</p>
<h3 id="1-2-无返回值的函数"><a href="#1-2-无返回值的函数" class="headerlink" title="1.2 无返回值的函数"></a>1.2 无返回值的函数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add_two</span>(i:<span class="type">i32</span>, j:<span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上写法等价于：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add_two</span>(i:<span class="type">i32</span>, j:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于返回一个空<code>()</code></p>
<h3 id="1-3-永远不返回函数"><a href="#1-3-永远不返回函数" class="headerlink" title="1.3 永远不返回函数"></a>1.3 永远不返回函数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add_two</span>(i:<span class="type">i32</span>, j:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;weeeeeee&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回类型就是一个<code>!</code></p>
<p>或者函数当中是一个死循环</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add_two</span>(i:<span class="type">i32</span>, j:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数中带<code>;</code>的为语句，不能作为返回值</li>
<li>不带<code>;</code>的为表达式，可以作为返回值</li>
</ul>
<h2 id="2-流程控制"><a href="#2-流程控制" class="headerlink" title="2 流程控制"></a>2 流程控制</h2><h3 id="2-1-条件控制"><a href="#2-1-条件控制" class="headerlink" title="2.1 条件控制"></a>2.1 条件控制</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;this value is 0&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> x == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;this value is 1&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;this value is not 1 or 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>this value is 1</p>
</blockquote>
<p>声明变量时的if语句：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">condition</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="keyword">if</span> condition &#123;</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;this value is 0&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> x == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;this value is 1&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;this value is not 1 or 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>this value is 0</p>
</blockquote>
<p>要点  </p>
<ol>
<li>变量赋值的if后面需要带<code>;</code></li>
<li>变量值不需要带<code>;</code></li>
<li>由于Rust是静态编译类型，所以if赋值的每一个分支都需要返回相同的类型</li>
</ol>
<h3 id="2-2-循环"><a href="#2-2-循环" class="headerlink" title="2.2 循环"></a>2.2 循环</h3><p>Rust中同样有三种方式实现循环：loop, while, for</p>
<ol>
<li>loop:</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：  </p>
<blockquote>
<p>20</p>
</blockquote>
<p>还有一种嵌套循环，可以给循环命名：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="symbol">&#x27;counting_up</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner_counter</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;inner_counter = &#123;&#125;&quot;</span>, inner_counter);</span><br><span class="line">            <span class="keyword">if</span> inner_counter == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> counter == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="symbol">&#x27;counting_up</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            inner_counter += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;counter = &#123;&#125;&quot;</span>, counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>inner_counter &#x3D; 0<br>inner_counter &#x3D; 1<br>inner_counter &#x3D; 2<br>inner_counter &#x3D; 0<br>inner_counter &#x3D; 1<br>inner_counter &#x3D; 2<br>inner_counter &#x3D; 0<br>counter &#x3D; 2</p>
</blockquote>
<ul>
<li><code>&#39;counting_up: loop</code>在开头使用单个<code>&#39;</code>来给<code>loop</code>命名。 </li>
<li><code>break</code>后也可以带上 <code>loop</code> 的名称结束指定循环。</li>
</ul>
<p>要注意表达式带返回值，而语句不带返回值，块表达式的值是其最后一行的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">        x + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the value of y = &#123;&#125;&quot;</span>, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个例子如上，此时假设x + 1结尾使用<code>;</code>则编译器将会报错。</p>
<ol start="2">
<li>while:</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> number != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, number);</span><br><span class="line">        number -= <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;LIFTOFF!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>while 遍历：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span>  <span class="variable">number</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> i &lt; number.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, number[i]);</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;LIFTOFF!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>for:</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span>  <span class="variable">number</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">e</span> <span class="keyword">in</span> number &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>range:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">e</span> <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该range不包含4，输出：</p>
<blockquote>
<p>1<br>2<br>3</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">e</span> <span class="keyword">in</span> (<span class="number">1</span>..=<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加上&#x3D;号该range包含4，输出：</p>
<blockquote>
<p>1<br>2<br>3<br>4</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">e</span> <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反序遍历输出：</p>
<blockquote>
<p>3<br>2<br>1</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">e</span> <span class="keyword">in</span> v &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, v[<span class="number">0</span>]); <span class="comment">// 该行会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println!(&quot;&#123;&#125;&quot;, v[0]);</span><br><span class="line">               ^ value borrowed here after move</span><br></pre></td></tr></table></figure>
<p>这是因为在for循环过程中，vector的每一个元素所有权都被转移到了for循环中，这个时候就无法使用<code>v[0]</code>来访问，而普通数组具有拷贝特性，所以不会发生这样的情况</p>
<p>我们可以在for循环中使用<code>借用</code>的方式来保留所有权，即<code>&amp;v</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">e</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, v[<span class="number">0</span>]); <span class="comment">// 该行会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种场景，即我们在遍历的过程中，希望改变所取元素的值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">e</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">        <span class="keyword">if</span> *e == <span class="number">2</span> &#123;</span><br><span class="line">            *e = <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, v[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时除了将vector改成可变类型外，由于e和v的类型在for循环中都是可变引用类型<code>&amp;mut</code>，赋值时应使用解引用符号去访问值<code>*e</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Kunqi Liu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kunqi Liu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
